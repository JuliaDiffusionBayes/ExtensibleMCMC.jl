var documenterSearchIndex = {"docs":
[{"location":"advanced_use/mcmc_schedule/#Scheduling-the-steps-to-take-with-MCMCSchedule-1","page":"MCMC Schedule","title":"Scheduling the steps to take with MCMCSchedule","text":"","category":"section"},{"location":"module_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [ExtensibleMCMC]","category":"page"},{"location":"module_index/#ExtensibleMCMC.GenericMCMCBackend","page":"Index","title":"ExtensibleMCMC.GenericMCMCBackend","text":"GenericMCMCBackend\n\nA flag that no specific backend is passed.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMC","page":"Index","title":"ExtensibleMCMC.MCMC","text":"mutable struct MCMC\n    updates::Vector\n    updates_and_decorators::Vector\n    backend::MCMCBackend\n    schedule::MCMCSchedule\n    workspace::GlobalWorkspace\nend\n\nA struct for defining a list of updates and specifying the backend algorithm doing the MCMC sampling. Any other functionality is done solely by the internal mechanizms of function the run!.\n\n    MCMC(\n        updt_and_decor::Vector{<:Union{MCMCUpdate,MCMCUpdateDecorator}};\n        backend=GenericMCMCBackend()\n    )\n\nThe main constructor of an `MCMC` struct. It accepts an array of updates and\nupdate decorators `updates_and_decorators` which together constitute a\nsingle MCMC step. Additionally, `backend` specialized to a particular,\noverarching MCMC algorithm (if it exists). An example of a backend would be\n`GuidedProposalsBackend`.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.RandomWalkUpdate","page":"Index","title":"ExtensibleMCMC.RandomWalkUpdate","text":"struct RandomWalkUpdate{TRW,TA,K} <: MCMCParamUpdate\n    rw::TRW\n    adpt::TA\n    loc2glob_idx::K\nend\n\nDefinition of an MCMC update that uses Metropolis-Hastings algorithm with random walk proposals.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.UniformRandomWalk","page":"Index","title":"ExtensibleMCMC.UniformRandomWalk","text":"mutable struct UniformRandomWalk{T,S} <: RandomWalk\n    ϵ::T\n    pos::S\nend\n\nA uniform random walker that moves all unrestricted coordinates according to the additive rule xᵢ+U, with U∼Unif(-ϵᵢ,ϵᵢ) and moves all coordinates restricted to be positive according to the rule xᵢexp(U), with U∼Unif(-ϵᵢ,ϵᵢ).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.run!-Tuple{MCMC,Any,Any,Any,Any}","page":"Index","title":"ExtensibleMCMC.run!","text":"run!(mcmc::MCMC, num_mcmc_steps, data, θinit, callbacks; kwargs...)\n\nThe main calling function of this package that initializes, runs and outputs the results of an MCMC sampler for discretely observed stochastic processes. mcmc specifies the sequence of updates that constitute a single MCMC step and provides additional info about the MCMC backend algorithm to be used. num_mcmc_steps is the total number of MCMC steps, data completely characterizes everything that is known about the observations (including everything known about the underlying dynamics and the way it was collected), θinit is the initial guess for the unknown parameters and callbacks is a collection of extra utility functions that do extra work around MCMC sampling. exclude_updates is a standard named argument which lists the update indices and corresponding ranges of MCMC iterations at which given updates are supposed to be omitted. Additional named arguments are passed onto initializers of global workspace and depend on the chosen MCMCBackend.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.Adaptation","page":"Index","title":"ExtensibleMCMC.Adaptation","text":"Adaptation\n\nSupertype for all adaptation schemes.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.AdaptationUnifRW","page":"Index","title":"ExtensibleMCMC.AdaptationUnifRW","text":"mutable struct AdaptationUnifRW{T} <: Adaptation\n    proposed::Int64\n    accepted::Int64\n    target_accpt_rate::Float64\n    adapt_every_k_steps::Int64\n    scale::T\n    min::T\n    max::T\n    offset::T\n    N::Int64\nend\n\nA struct containing information about the way in which to adapt the steps of the uniform random walker. proposed and accepted are the internal counters that keep track of the number of proposed and accepted samples. target_accpt_rate is the acceptance rate of the Metropolis-Hastings steps that is supposed to be targetted. min is used to enforce the minimal allowable range that the random walker can sample from, max enforces the maximum. offset introduces some delay in the start of decelerting the adaptation extent and scale is a scaling parameter for adaptation speed. N is the number of coordinates of the random walker.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.AdaptationUnifRW-Union{Tuple{K}, Tuple{K}} where K","page":"Index","title":"ExtensibleMCMC.AdaptationUnifRW","text":"AdaptationUnifRW(θ::K; kwargs...) where K\n\nDefine an adaptation scheme for a random walker that does updates on the parameter of shape and type θ. The following named parameters can be specified ...\n\nArguments\n\nadapt_every_k_steps=100: number of steps based on which adaptation happens\ntarget_accpt_rate=0.234: acceptance rate of MH step that is to be targetted\nscale=1.0: scaling of the adaptation\nmin=1e-12: minimum allowable (half)-range of the uniform sampler\nmax=1e7: maximum allowable (half)-range of the unifor sampler\noffset=1e2: number of adaptation steps after which the shrinking of adaptive               steps is supposed to start.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.Callback","page":"Index","title":"ExtensibleMCMC.Callback","text":"Callback\n\nSupertype of all callbacks. They specify additional actions that can be performed before or after each MCMC step or at the very end of sampling.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.GlobalWorkspace","page":"Index","title":"ExtensibleMCMC.GlobalWorkspace","text":"GlobalWorkspace{T} <: Workspace\n\nSupertype of all global workspaces. Each MCMC sampler must have a unique global workspace, which contains state, state_history, state_proposal_history, acceptance_history and data. state is the paramater vector that the MCMC sampling is done for (other names being self-explanatory).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.ImproperPrior","page":"Index","title":"ExtensibleMCMC.ImproperPrior","text":"ImproperPrior\n\nFlat prior\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.LocalWorkspace","page":"Index","title":"ExtensibleMCMC.LocalWorkspace","text":"LocalWorkspace{T} <: Workspace\n\nSupertype of all local workspaces. Local workspace should contain any additional gathering of objects that are needed by specific updates, but are not are not already in a global workspace. Each MCMC update has its own LocalWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCBackend","page":"Index","title":"ExtensibleMCMC.MCMCBackend","text":"MCMCBackend\n\nSupertype of all backends for the MCMC sampler.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCConjugateUpdate","page":"Index","title":"ExtensibleMCMC.MCMCConjugateUpdate","text":"MCMCConjugateUpdate <: MCMCUpdate\n\nSupertype of all conjugate updates, for which sampling can be done directly, without resorting to a Metropolis-Hastings algorithm\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCGradientBasedUpdate","page":"Index","title":"ExtensibleMCMC.MCMCGradientBasedUpdate","text":"MCMCGradientBasedUpdate <: MCMCParamUpdate\n\nSupertype of all updates that require local gradient information to perform update of state.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCImputation","page":"Index","title":"ExtensibleMCMC.MCMCImputation","text":"MCMCImputation <: MCMCUpdate\n\nSupertype of all updates that do not make any changes to the main parameter state in GlobalWorkspace, but instead, perform sampling on any auxiliary variables that are not of direct interest to the MCMC chain.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCParamUpdate","page":"Index","title":"ExtensibleMCMC.MCMCParamUpdate","text":"MCMCParamUpdate <: MCMCUpdate\n\nSupertype of all updates that make changes to the main MCMC parameter called state in the GlobalWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCSchedule","page":"Index","title":"ExtensibleMCMC.MCMCSchedule","text":"mutable struct MCMCSchedule\n    num_mcmc_steps::Int64\n    num_updates::Int64\n    start::NamedTuple{(:mcmciter, :pidx),Tuple{Int64,Int64}}\n    exclude_updates::DefaultDict{Int64,OrdinalRange{Int64,Int64},UnitRange{Int64}}\nend\n\nAn object used for iterating over the steps of MCMC samplers. num_mcmc_steps is the total number of MCMC steps, whereas num_updates is a total number of separate updates that can be performed in a single MCMC step. Not all of those updates have to be performed and the pattern of excluding the updates is stored in exclude_updates. The num_updates and exclude_updates can change in the midst of iterating through the MCMCSchedule and the iterator will register that and act accordingly.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCUpdate","page":"Index","title":"ExtensibleMCMC.MCMCUpdate","text":"MCMCUpdate\n\nSupertype of all MCMC updates\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCUpdateDecorator","page":"Index","title":"ExtensibleMCMC.MCMCUpdateDecorator","text":"MCMCUpdateDecorator\n\nSupertype of all decorators to update schemes. In this context, we use the word decorator to refer to any additional information that needs to be conveyed to the MCMC sampler that is not directly extractable from the update-objects themselves (for instance, a change in the delimitation of blocks that is made in-between updates).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.NoAdaptation","page":"Index","title":"ExtensibleMCMC.NoAdaptation","text":"NoAdaptation\n\nA struct-flag for indicating that no adaptation is to be done.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.RandomWalk","page":"Index","title":"ExtensibleMCMC.RandomWalk","text":"RandomWalk <: TransitionKernel\n\nSupertype for all random walkers.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.SavingCallback","page":"Index","title":"ExtensibleMCMC.SavingCallback","text":"struct SavingCallback <: Callback\n    save_at_the_end::Bool\n    save_intermediate::Bool\n    save_at_iters::Vector{Int64}\n    filename::String\nend\n\nStruct for saving the intermediate or final states of the sampled chain to the disk.\n\n    SavingCallback(;\n        save_at_the_end=true,\n        save_at_iters=[],\n        overwrite]=false,\n        filename=\"mcmc_results\",\n        add_datestamp=false,\n        path=\".\",\n    )\n\nThe main constructor for `SavingCallback`. `save_at_the_end` is an indicator\nflag for whether to save to a file at the end of mcmc sampling,\n`save_at_iters` additionally specifies at which intermediate iterations\nthe chain should be saved to a file, `overwrite` if set to true will\noverwrite any already existing file that shares the name with the one passed\nto this function. `filename` is the main stem of the file's name,\n`add_datestamps` will add the date and time at the time of creating the\ncallback to the filename and `path` specifies the directory path to save to.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.TransitionKernel","page":"Index","title":"ExtensibleMCMC.TransitionKernel","text":"TransitionKernel\n\nSupertype of all transition kernels that perform updates on the main state of the global workspace. Conceptually, these are used by subtypes of MCMCParamUpdate to perform actual sampling and instances of types inheriting from TransitionKernel are usually member objects of the instances inheriting from MCMCParamUpdate.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.Workspace","page":"Index","title":"ExtensibleMCMC.Workspace","text":"Workspace\n\nSupertype of all workspaces–-i.e. of structs that gather in one place various objects that the MCMC sampler operates on.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#Base.:==-Union{Tuple{S}, Tuple{T}, Tuple{ExtensibleMCMC.AdaptationUnifRW{T},ExtensibleMCMC.AdaptationUnifRW{S}}} where S where T","page":"Index","title":"Base.:==","text":"Base.:(==)(a::AdaptationUnifRW{T}, b::AdaptationUnifRW{S}) where{T,S}\n\nConvenience comparison of AdaptationUnifRW instances. Used only for tests.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.iterate","page":"Index","title":"Base.iterate","text":"Base.iterate(iter::MCMCSchedule, state=iter.start)\n\nIterate through the MCMCSchedule, outputting the named tuples (mcmciter=..., pidx=...) along the way, indicating the current index of the mcmc sampler (mcmciter), as well as the index of update that is to be performed.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Base.rand-Tuple{UniformRandomWalk,Any}","page":"Index","title":"Base.rand","text":"Base.rand(rw::UniformRandomWalk, θ)\n\nSample a new state for a random walker rw that is currently in a state θ.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DataStructures.reset!-Tuple{ExtensibleMCMC.AdaptationUnifRW}","page":"Index","title":"DataStructures.reset!","text":"reset!(adpt::AdaptationUnifRW)\n\nReset the number of proposals and accepted samples to zero.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Distributions.logpdf-Tuple{UniformRandomWalk,Any,Any}","page":"Index","title":"Distributions.logpdf","text":"Distributions.logpdf(rw::UniformRandomWalk, θ, θ°)\n\nEvaluate the log-probability density function for a move of a random walker from θ to θ°.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._AdaptationUnifRW-Union{Tuple{N}, Tuple{Any,Val{:scalar},Val{N},Any,Any}} where N","page":"Index","title":"ExtensibleMCMC._AdaptationUnifRW","text":"_AdaptationUnifRW(\n        ::Any, ::Val{:scalar}, ::Val{N}, trgt_ar, steps; kwargs...\n    ) where N\n\nInternal constructor of AdaptationUnifRW, populating entries with scalars.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._AdaptationUnifRW-Union{Tuple{N}, Tuple{Val{false},Val{:nonscalar},Val{N},Any,Any}} where N","page":"Index","title":"ExtensibleMCMC._AdaptationUnifRW","text":"_AdaptationUnifRW(\n        ::Val{false}, ::Val{:nonscalar}, v::Val{N}, trgt_ar, steps; kwargs...\n    ) where N\n\nInternal constructor of AdaptationUnifRW, populating entries with SVectors.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._AdaptationUnifRW-Union{Tuple{N}, Tuple{Val{true},Val{:nonscalar},Val{N},Any,Any}} where N","page":"Index","title":"ExtensibleMCMC._AdaptationUnifRW","text":"_AdaptationUnifRW(\n        ::Val{true}, ::Val{:nonscalar}, ::Val{N}, trgt_ar, steps; kwargs...\n    ) where N\n\nInternal constructor of AdaptationUnifRW, populating entries with vectors.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.__run!-NTuple{5,Any}","page":"Index","title":"ExtensibleMCMC.__run!","text":"__run!(global_ws, local_wss, updates, schedule, callbacks)\n\nInternal loops that run the (already initialized) MCMC sampler. global_ws and local_wss are the already initialized global workspace and local workspaces (one for each update) respectively. schedule is the iterator over MCMC steps and callbacks is a list of callbacks.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._adpt_rw_fill_defaults-Tuple{Any}","page":"Index","title":"ExtensibleMCMC._adpt_rw_fill_defaults","text":"_adpt_rw_fill_defaults(N; kwargs...)\n\nReturn a vector with set vector parameters, falling back on default values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._adpt_rw_fill_defaults-Tuple{Function}","page":"Index","title":"ExtensibleMCMC._adpt_rw_fill_defaults","text":"_adpt_rw_fill_defaults(f::Function)\n\nReturn a vector with set parameters, setting them according to the \"recipe\" f, falling back on default values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._adpt_rw_fill_defaults-Tuple{}","page":"Index","title":"ExtensibleMCMC._adpt_rw_fill_defaults","text":"_adpt_rw_fill_defaults(; kwargs...)\n\nReturn a vector with set scalar parameters, falling back on default values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._adpt_rw_fill_defaults-Union{Tuple{Val{N}}, Tuple{N}} where N","page":"Index","title":"ExtensibleMCMC._adpt_rw_fill_defaults","text":"_adpt_rw_fill_defaults(N; kwargs...)\n\nReturn a vector with set SVector parameters, falling back on default values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._assure_scalar-Tuple{Any}","page":"Index","title":"ExtensibleMCMC._assure_scalar","text":"_assure_scalar(v)\n\nAccept a scalar or a vector of length one and return it as a scalar. Raise assertion error if other objects are passed.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._upgrade_to_svec-Union{Tuple{N}, Tuple{Any,Val{N}}} where N","page":"Index","title":"ExtensibleMCMC._upgrade_to_svec","text":"_upgrade_to_svec(v, ::Val{N}) where N\n\nReceive a scalar or a vector of length 1 and return a length N static vector of repeats of entry v.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._upgrade_to_vec-Tuple{Any,Any}","page":"Index","title":"ExtensibleMCMC._upgrade_to_vec","text":"_upgrade_to_vec(v, N)\n\nReceive a scalar or a vector of length 1 and return a length N vector of repeats of entry v.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.acceptance_rate!-Tuple{ExtensibleMCMC.AdaptationUnifRW}","page":"Index","title":"ExtensibleMCMC.acceptance_rate!","text":"acceptance_rate!(adpt::AdaptationUnifRW)\n\nDestructive computation of a current acceptance rate that also resets the number of proposals and accepted samples to zeros.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.acceptance_rate-Tuple{ExtensibleMCMC.AdaptationUnifRW}","page":"Index","title":"ExtensibleMCMC.acceptance_rate","text":"acceptance_rate(adpt::AdaptationUnifRW)\n\nCompute current acceptance rate of the Metropolis-Hastings update step\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.check_if_execute-Tuple{ExtensibleMCMC.Callback,Any}","page":"Index","title":"ExtensibleMCMC.check_if_execute","text":"check_if_execute(callback::Callback, iter)\n\nCheck if callback is supposed to be executed at the mcmc iteration iter.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.check_if_execute-Tuple{ExtensibleMCMC.SavingCallback,Any}","page":"Index","title":"ExtensibleMCMC.check_if_execute","text":"check_if_execute(callback::SavingCallback, iter)\n\nReturn true if the mcmc iteration iter is one at which an intermediate save is to be made.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.cleanup!-Tuple{ExtensibleMCMC.Callback,ExtensibleMCMC.GlobalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.cleanup!","text":"cleanup!(callback::Callback, ws::GlobalWorkspace, iter)\n\nThe last call to callback, after all MCMC steps and before exiting the function run.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.cleanup!-Tuple{ExtensibleMCMC.SavingCallback,ExtensibleMCMC.GlobalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.cleanup!","text":"cleanup!(callback::SavingCallback, ws::GlobalWorkspace, iter)\n\nSave the entire MCMC chain, history of proposals, acceptance history etc.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.compute_δ-Tuple{Any,Any}","page":"Index","title":"ExtensibleMCMC.compute_δ","text":"compute_δ(p, mcmc_iter)\n\nδ decreases roughly proportional to scale/sqrt(iteration)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.compute_ϵ","page":"Index","title":"ExtensibleMCMC.compute_ϵ","text":"compute_ϵ(ϵ_old, p, a_r, δ, flip=1.0, f=identity, finv=identity)\n\nϵ is moved by δ to adapt to target acceptance rate\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.custom_zero-Union{Tuple{elT}, Tuple{T}, Tuple{T,Type{elT}}} where elT where T","page":"Index","title":"ExtensibleMCMC.custom_zero","text":"custom_zero(x::T, ::Type{elT}) where {T,elT}\n\nCreate a zero with eltype elT, that is of the same structure as the collection x.\n\nExamples\n\njulia> custom_zero(3.0, Bool)\nfalse\njulia> custom_zero([3.0, 4.0], Bool)\n2-element Array{Bool,1}:\n 0\n 0\njulia> custom_zero(SVector{2}(1, 2), ComplexF64)\n2-element SArray{Tuple{2},Complex{Float64},1,2} with indices SOneTo(2):\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.data_to_csv-Tuple{Any,ExtensibleMCMC.GlobalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.data_to_csv","text":"data_to_csv(f, ws::GlobalWorkspace, i)\n\nWrite data entries to a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.execute!-Tuple{ExtensibleMCMC.Callback,ExtensibleMCMC.LocalWorkspace,ExtensibleMCMC.GlobalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.execute!","text":"execute!(callback::Callback, ws::GlobalWorkspace, iter)\n\nExecute the callback.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.execute!-Tuple{ExtensibleMCMC.SavingCallback,ExtensibleMCMC.LocalWorkspace,ExtensibleMCMC.GlobalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.execute!","text":"execute!(sc::SavingCallback, ws::GlobalWorkspace, iter)\n\nSave the chain of accepted states, proposed states and acceptance history to the disk.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.find_available_name","page":"Index","title":"ExtensibleMCMC.find_available_name","text":"find_available_name(path, filename, disambig_num, extension=\".csv\")\n\nCheck if a chosen filename already exists, if so, then tries appending consecutive numbers to the end of the file until the first one that is not used yet is found.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.find_starting_idx-Tuple{ExtensibleMCMC.SavingCallback,Any}","page":"Index","title":"ExtensibleMCMC.find_starting_idx","text":"find_starting_idx(callback::SavingCallback, iter)\n\nFind the last index for which saving was done.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.get_decorators-Tuple{Any}","page":"Index","title":"ExtensibleMCMC.get_decorators","text":"get_decorators(updt_and_decor)\n\nRetrieve all decorators from a list\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.init!","page":"Index","title":"ExtensibleMCMC.init!","text":"init!(\n    mcmc::MCMC,\n    num_mcmc_steps,\n    data,\n    θinit,\n    exclude_updates=[];\n    kwargs...\n)\n\nInitialize the schedule and the global workspace of the MCMC sampler for a given set of updates (already saved in mcmc.updates), a total number of MCMC iterations given by num_mcmc_steps, observed dataset data. θinit is the initial value of the main parameter that the MCMC sampling is done for, exclude_updates lists the update indices and the repspective ranges of mcmc iterations from which these updates are supposed to be omitted from and kwargs lists all additional named arguments passed for creating a global workspace.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.init!-Tuple{ExtensibleMCMC.Callback,ExtensibleMCMC.GlobalWorkspace}","page":"Index","title":"ExtensibleMCMC.init!","text":"init!(::Callback)\n\nInitialization actions for a callback. By default nothing to be done.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.init!-Tuple{ExtensibleMCMC.SavingCallback,ExtensibleMCMC.GlobalWorkspace}","page":"Index","title":"ExtensibleMCMC.init!","text":"init!(callback::SavingCallback)\n\nCreate a CSV file for writing into.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.isdecorator-Tuple{Any}","page":"Index","title":"ExtensibleMCMC.isdecorator","text":"isdecorator(u)\n\nReturns true if u is a subtype of decorators.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.isequal_except-Union{Tuple{S}, Tuple{T}, Tuple{ExtensibleMCMC.AdaptationUnifRW{T},ExtensibleMCMC.AdaptationUnifRW{S},Vararg{Any,N} where N}} where S where T","page":"Index","title":"ExtensibleMCMC.isequal_except","text":"isequal_except(\n    ::AdaptationUnifRW{T}, b::AdaptationUnifRW{S}, args...\n    ) where{T,S}\n\nConvenience comparison of AdaptationUnifRW instances. Used only for tests. The fields specified by args are excluded from comparison.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.logit","page":"Index","title":"ExtensibleMCMC.logit","text":"logit(x, a=1.0)\n\nLogit function. (Inverse of sigmoid).\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.proposal!-Tuple{RandomWalkUpdate,Any,Any,Any}","page":"Index","title":"ExtensibleMCMC.proposal!","text":"proposal!(updt::RandomWalkUpdate, ws, global_ws, step)\n\nSample a proposal value for the MCMC's local state variable.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.readjust!-Tuple{UniformRandomWalk,ExtensibleMCMC.AdaptationUnifRW,Any}","page":"Index","title":"ExtensibleMCMC.readjust!","text":"readjust!(rw::UniformRandomWalk, adpt::AdaptationUnifRW, mcmc_iter)\n\nAdaptive readjustment of the range for sampling uniforms by the random walker.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.register!-Tuple{ExtensibleMCMC.AdaptationUnifRW,Bool,Any}","page":"Index","title":"ExtensibleMCMC.register!","text":"register!(adpt::AdaptationUnifRW, accepted::Bool, ::Any)\n\nRegister the result of the acceptance decision in the Metropolis-Hastings step.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.reschedule!","page":"Index","title":"ExtensibleMCMC.reschedule!","text":"reschedule!(\n    schedule::MCMCSchedule,\n    num_new_updates=0,\n    idxes_to_remove=[],\n    idxes_to_add=[]\n)\n\nMake changes to the schedule (possibly in the midst of iterating through it). Add num_new_updtes-many allowable updates that can be performed at each MCMC step, idxes_to_remove lists all parameter udpates that are to be completely removed from the MCMC sampler, idxes_to_add lists entries that are to be added to schedule.exclude_updates.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.sigmoid","page":"Index","title":"ExtensibleMCMC.sigmoid","text":"sigmoid(x, a=1.0)\n\nSigmoid function. (Inverse of logit).\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.strip_decorators-Tuple{Any}","page":"Index","title":"ExtensibleMCMC.strip_decorators","text":"strip_decorators(updt_and_decor)\n\nRemove all decorators from a list\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.transition-Tuple{ExtensibleMCMC.MCMCSchedule,Any}","page":"Index","title":"ExtensibleMCMC.transition","text":"transition(schedule::MCMCSchedule, state)\n\nDetermine the next state of the MCMCSchedule iterator, by skipping through all updates that are to be excluded, as per schedule.exclude_updates.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.update!-Tuple{ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.LocalWorkspace,ExtensibleMCMC.GlobalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.update!","text":"update!(\n    updt::MCMCParamUpdate,\n    ws::LocalWorkspace,\n    ws_global::GlobalWorkspace,\n    step\n)\n\nGeneral recipe for performing parameter update (doing an update of the main state of the MCMC sampler).\n\n\n\n\n\n","category":"method"},{"location":"advanced_use/internal_structure/#Understanding-the-internal-components-of-the-sampler-1","page":"Internal structure","title":"Understanding the internal components of the sampler","text":"","category":"section"},{"location":"advanced_use/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"(Image: internal structure)","category":"page"},{"location":"overview/callbacks/#Callbacks-1","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"overview/callbacks/#ProgressPrintCallback-1","page":"Callbacks","title":"ProgressPrintCallback","text":"","category":"section"},{"location":"overview/callbacks/#SavingCallback-1","page":"Callbacks","title":"SavingCallback","text":"","category":"section"},{"location":"advanced_use/priors/#Defining-custom-priors-1","page":"Priors","title":"Defining custom priors","text":"","category":"section"},{"location":"overview/updates/#Updates-1","page":"Updates","title":"Updates","text":"","category":"section"},{"location":"overview/updates/#Random-Walk-proposals-1","page":"Updates","title":"Random Walk proposals","text":"","category":"section"},{"location":"overview/updates/#Uniform-Random-Walker-1","page":"Updates","title":"Uniform Random Walker","text":"","category":"section"},{"location":"overview/updates/#Restricting-coordinates-to-positive-values-1","page":"Updates","title":"Restricting coordinates to positive values","text":"","category":"section"},{"location":"overview/updates/#Adaptation-1","page":"Updates","title":"Adaptation","text":"","category":"section"},{"location":"overview/updates/#Gaussian-Random-Walker-1","page":"Updates","title":"Gaussian Random Walker","text":"","category":"section"},{"location":"overview/updates/#Restricting-coordinates-to-positive-values-2","page":"Updates","title":"Restricting coordinates to positive values","text":"","category":"section"},{"location":"overview/updates/#Adaptation-2","page":"Updates","title":"Adaptation","text":"","category":"section"},{"location":"overview/updates/#Metropolis-adjusted-Langevin-algorithm-(MALA)-1","page":"Updates","title":"Metropolis-adjusted Langevin algorithm (MALA)","text":"","category":"section"},{"location":"overview/updates/#Hamiltonian-Monte-Carlo-1","page":"Updates","title":"Hamiltonian Monte Carlo","text":"","category":"section"},{"location":"advanced_use/updates_and_decorators/#Custom-MCMC-updates-and-decorators-1","page":"Updates & Decorators","title":"Custom MCMC updates and decorators","text":"","category":"section"},{"location":"overview/priors/#Priors-1","page":"Priors","title":"Priors","text":"","category":"section"},{"location":"overview/priors/#Improper-priors-1","page":"Priors","title":"Improper priors","text":"","category":"section"},{"location":"overview/priors/#Standard-priors-relying-on-Distributions.jl-1","page":"Priors","title":"Standard priors relying on Distributions.jl","text":"","category":"section"},{"location":"overview/basic_use/#Overview-of-ExtensibleMCMC.jl's-basic-functionality-1","page":"Basic use","title":"Overview of ExtensibleMCMC.jl's basic functionality","text":"","category":"section"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"For simplest problems all that needs to be provided by the user is a target law, a function that sets the parameters of the target law and a function that evaluates the log-likelihood at the observations. The remaining options can be chosen from a set of objects already pre-defined in this package. Let's look at an example.","category":"page"},{"location":"overview/basic_use/#Estimating-the-mean-of-a-bivariate-Guassian-1","page":"Basic use","title":"Estimating the mean of a bivariate Guassian","text":"","category":"section"},{"location":"overview/basic_use/#Defining-the-target-law-1","page":"Basic use","title":"Defining the target law","text":"","category":"section"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"In this folder we have already defined some examples of the targets laws and a Gaussian law (with a possibility to estimate its mean and covariance matrix) is one of them. For the pedagogical purposes we define the new BivariateGaussian struct below.","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"We start from defining the target law.","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"using Distributions\nusing ExtensibleMCMC\nconst eMCMC = ExtensibleMCMC\n\nmutable struct BivariateGaussian{T}\n    P::T\n    function BivariateGaussian(μ, Σ)\n        @assert length(μ) == 2 && size(Σ) == (2,2)\n        P = MvNormal(μ, Σ)\n        new{typeof(P)}(P)\n    end\nend","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"We must provide two functions for it. The first one is a setter of new parameters","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"function eMCMC.new_parameters!(gsn::BivariateGaussian, loc2glob_idx, θ)\n    μ, Σ = params(gsn.P)\n    μ[loc2glob_idx] .= θ\n    gsn.P = MvNormal(μ, Σ)\nend","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"where loc2glob_idx is a vector of indices pointing to parameters that are to be updated. The second one evaluates the log-likelihood:","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"function Distributions.loglikelihood(gsn::BivariateGaussian, observs)\n    ll = 0.0\n    for obs in observs\n        ll += logpdf(gsn.P, obs)\n    end\n    ll\nend","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"And we're good to go.","category":"page"},{"location":"overview/basic_use/#Generating-the-data-1","page":"Basic use","title":"Generating the data","text":"","category":"section"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"We may simulate some test data. The important point is that unless you overload the update functions yourself, the data should be stored in the format of a NamedTuple with fields P containing the target law and obs with a vector of observations.","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"using Random\nRandom.seed!(10)\nμ, Σ = [1.0, 2.0], [1.0 0.5; 0.5 1.0]\ntrgt = MvNormal(μ, Σ)\nnum_obs = 10\n\ndata = (\n    P = BivariateGaussian(rand(2), Σ),\n    obs = [rand(trgt) for _ in 1:num_obs],\n)","category":"page"},{"location":"overview/basic_use/#Parametrizing-the-MCMC-sampler-1","page":"Basic use","title":"Parametrizing the MCMC sampler","text":"","category":"section"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"Parametrizing the Monte Carlo sampler boils down to specifying a list of updates (out of a list provided in this package plus additional updates defined by you) passed as a vector to an MCMC struct. Each update usually contains","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"specification of a transition kernel\nan index or indices of a parameter vector that is/are being updated\na corresponding prior on the parameters\nadditional information about adaptation scheme","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"Additionally, we may pass a backend to MCMC to specify what type of Workspaces need to be initialized. For now we will not use any adaptation and we will use a default backend.","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"Apart from MCMC struct we need to pass the number of mcmc steps, the data and an initial guess for an unknown parameter vector.","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"Finally, we have an option to pass Callbacks. For now let's leave these empty. We will discuss them in detail in (...).","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(UniformRandomWalk([1.0]), [1]; prior=ImproperPrior()),\n            RandomWalkUpdate(UniformRandomWalk([1.0]), [2]; prior=ImproperPrior()),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)","category":"page"},{"location":"overview/basic_use/#Running-the-sampler-1","page":"Basic use","title":"Running the sampler","text":"","category":"section"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"With parameterization of the sampler in place, running it is a one-liner","category":"page"},{"location":"overview/basic_use/#","page":"Basic use","title":"Basic use","text":"workspace = run!(mcmc_params...)","category":"page"},{"location":"advanced_use/callbacks/#Writing-custom-callbacks-1","page":"Callbacks","title":"Writing custom callbacks","text":"","category":"section"},{"location":"#ExtensibleMCMC.jl-1","page":"Home","title":"ExtensibleMCMC.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A modular implementation of the Markov chain Monte Carlo (MCMC) algorithm focused on the ease of its extensibility.","category":"page"},{"location":"advanced_use/workspaces/#The-idea-behind-Workspaces-1","page":"Workspaces","title":"The idea behind Workspaces","text":"","category":"section"},{"location":"advanced_use/workspaces/#Workspaces-inheriting-from-GlobalWorkspace-1","page":"Workspaces","title":"Workspaces inheriting from GlobalWorkspace","text":"","category":"section"},{"location":"advanced_use/workspaces/#Workspaces-inheriting-from-LocalWorkspace-1","page":"Workspaces","title":"Workspaces inheriting from LocalWorkspace","text":"","category":"section"},{"location":"advanced_use/workspaces/#Leveraging-multiple-dispatch-for-specializing-updates-for-custom-workspaces-1","page":"Workspaces","title":"Leveraging multiple dispatch for specializing updates for custom workspaces","text":"","category":"section"}]
}
