var documenterSearchIndex = {"docs":
[{"location":"module_index/#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"module_index/#","page":"Index","title":"Index","text":"","category":"page"},{"location":"module_index/#","page":"Index","title":"Index","text":"Modules = [ExtensibleMCMC]","category":"page"},{"location":"module_index/#ExtensibleMCMC.AdaptationUnifRW-Union{Tuple{K}, Tuple{K}} where K","page":"Index","title":"ExtensibleMCMC.AdaptationUnifRW","text":"AdaptationUnifRW(θ::K; kwargs...) where K\n\nDefine an adaptation scheme for a random walker that does updates on the parameter of shape and type θ. The following named parameters can be specified ...\n\nArguments\n\nadapt_every_k_steps=100: number of steps based on which adaptation happens\ntarget_accpt_rate=0.234: acceptance rate of MH step that is to be targetted\nscale=1.0: scaling of the adaptation\nmin=1e-12: minimum allowable (half)-range of the uniform sampler\nmax=1e7: maximum allowable (half)-range of the unifor sampler\noffset=1e2: number of adaptation steps after which the shrinking of adaptive               steps is supposed to start.\n\n...\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.GenericChainStats","page":"Index","title":"ExtensibleMCMC.GenericChainStats","text":"mutable struct GenericChainStats{T} <: ChainStats\n    rolling_ar::Vector{Vector{Float64}}\n    roll_window::Int64\n    mean::Vector{T}\n    cov::Matrix{T}\n    N::Int64\nend\n\nSimple online statistics for the Markov chain.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.GenericMCMCBackend","page":"Index","title":"ExtensibleMCMC.GenericMCMCBackend","text":"GenericMCMCBackend\n\nA flag that no specific backend is passed.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.ImproperPrior","page":"Index","title":"ExtensibleMCMC.ImproperPrior","text":"ImproperPrior\n\nFlat prior\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMC","page":"Index","title":"ExtensibleMCMC.MCMC","text":"mutable struct MCMC\n    updates::Vector\n    updates_and_decorators::Vector\n    backend::MCMCBackend\n    schedule::MCMCSchedule\n    workspace::GlobalWorkspace\nend\n\nA struct for defining a list of updates and specifying the backend algorithm doing the MCMC sampling. Any other functionality is done solely by the internal mechanizms of function the run!.\n\n    MCMC(\n        updt_and_decor::Vector{<:Union{MCMCUpdate,MCMCUpdateDecorator}};\n        backend=GenericMCMCBackend()\n    )\n\nThe main constructor of an `MCMC` struct. It accepts an array of updates and\nupdate decorators `updates_and_decorators` which together constitute a\nsingle MCMC step. Additionally, `backend` specialized to a particular,\noverarching MCMC algorithm (if it exists). An example of a backend would be\n`GuidedProposalsBackend`.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.get_decorators-Tuple{Any}","page":"Index","title":"ExtensibleMCMC.get_decorators","text":"get_decorators(updt_and_decor)\n\nRetrieve all decorators from a list\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.isdecorator-Tuple{Any}","page":"Index","title":"ExtensibleMCMC.isdecorator","text":"isdecorator(u)\n\nReturns true if u is a subtype of decorators.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.run!","page":"Index","title":"ExtensibleMCMC.run!","text":"run!(mcmc::MCMC, num_mcmc_steps, data, θinit, callbacks; kwargs...)\n\nThe main calling function of this package that initializes, runs and outputs the results of an MCMC sampler for discretely observed stochastic processes. mcmc specifies the sequence of updates that constitute a single MCMC step and provides additional info about the MCMC backend algorithm to be used. num_mcmc_steps is the total number of MCMC steps, data completely characterizes everything that is known about the observations (including everything known about the underlying dynamics and the way it was collected), θinit is the initial guess for the unknown parameters and callbacks is a collection of extra utility functions that do extra work around MCMC sampling. exclude_updates is a standard named argument which lists the update indices and corresponding ranges of MCMC iterations at which given updates are supposed to be omitted. Additional named arguments are passed onto initializers of global workspace and depend on the chosen MCMCBackend.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.Adaptation","page":"Index","title":"ExtensibleMCMC.Adaptation","text":"Adaptation\n\nSupertype for all adaptation schemes.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCConjugateUpdate","page":"Index","title":"ExtensibleMCMC.MCMCConjugateUpdate","text":"MCMCConjugateUpdate <: MCMCUpdate\n\nSupertype of all conjugate updates, for which sampling can be done directly, without resorting to a Metropolis-Hastings algorithm\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCGradientBasedUpdate","page":"Index","title":"ExtensibleMCMC.MCMCGradientBasedUpdate","text":"MCMCGradientBasedUpdate <: MCMCParamUpdate\n\nSupertype of all updates that require local gradient information to perform update of state.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCImputation","page":"Index","title":"ExtensibleMCMC.MCMCImputation","text":"MCMCImputation <: MCMCUpdate\n\nSupertype of all updates that do not make any changes to the main parameter state in GlobalWorkspace, but instead, perform sampling on any auxiliary variables that are not of direct interest to the MCMC chain.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCParamUpdate","page":"Index","title":"ExtensibleMCMC.MCMCParamUpdate","text":"MCMCParamUpdate <: MCMCUpdate\n\nSupertype of all updates that make changes to the main MCMC parameter called state in the GlobalWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCSchedule","page":"Index","title":"ExtensibleMCMC.MCMCSchedule","text":"mutable struct MCMCSchedule\n    num_mcmc_steps::Int64\n    num_updates::Int64\n    start::NamedTuple{(:mcmciter, :pidx),Tuple{Int64,Int64}}\n    exclude_updates::DefaultDict{Int64,OrdinalRange{Int64,Int64},UnitRange{Int64}}\nend\n\nAn object used for iterating over the steps of MCMC samplers. num_mcmc_steps is the total number of MCMC steps, whereas num_updates is a total number of separate updates that can be performed in a single MCMC step. Not all of those updates have to be performed and the pattern of excluding the updates is stored in exclude_updates. The num_updates and exclude_updates can change in the midst of iterating through the MCMCSchedule and the iterator will register that and act accordingly.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCUpdate","page":"Index","title":"ExtensibleMCMC.MCMCUpdate","text":"MCMCUpdate\n\nSupertype of all MCMC updates\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.MCMCUpdateDecorator","page":"Index","title":"ExtensibleMCMC.MCMCUpdateDecorator","text":"MCMCUpdateDecorator\n\nSupertype of all decorators to update schemes. In this context, we use the word decorator to refer to any additional information that needs to be conveyed to the MCMC sampler that is not directly extractable from the update-objects themselves (for instance, a change in the delimitation of blocks that is made in-between updates).\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.NoAdaptation","page":"Index","title":"ExtensibleMCMC.NoAdaptation","text":"NoAdaptation\n\nA struct-flag for indicating that no adaptation is to be done.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.RandomWalk","page":"Index","title":"ExtensibleMCMC.RandomWalk","text":"RandomWalk <: TransitionKernel\n\nSupertype for all random walkers.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.TransitionKernel","page":"Index","title":"ExtensibleMCMC.TransitionKernel","text":"TransitionKernel\n\nSupertype of all transition kernels that perform updates on the main state of the global workspace. Conceptually, these are used by subtypes of MCMCParamUpdate to perform actual sampling and instances of types inheriting from TransitionKernel are usually member objects of the instances inheriting from MCMCParamUpdate.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#ExtensibleMCMC.Workspace","page":"Index","title":"ExtensibleMCMC.Workspace","text":"Workspace\n\nSupertype of all workspaces–-i.e. of structs that gather in one place various objects that the MCMC sampler operates on.\n\n\n\n\n\n","category":"type"},{"location":"module_index/#Base.:==-Union{Tuple{S}, Tuple{T}, Tuple{AdaptationUnifRW{T},AdaptationUnifRW{S}}} where S where T","page":"Index","title":"Base.:==","text":"Base.:(==)(a::AdaptationUnifRW{T}, b::AdaptationUnifRW{S}) where{T,S}\n\nConvenience comparison of AdaptationUnifRW instances. Used only for tests.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Base.iterate","page":"Index","title":"Base.iterate","text":"Base.iterate(iter::MCMCSchedule, state=iter.start)\n\nIterate through the MCMCSchedule, outputting the named tuples (mcmciter=..., pidx=...) along the way, indicating the current index of the mcmc sampler (mcmciter), as well as the index of update that is to be performed.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#Base.rand-Tuple{UniformRandomWalk,Any}","page":"Index","title":"Base.rand","text":"Base.rand(rw::UniformRandomWalk, θ)\n\nSample a new state for a random walker rw that is currently in a state θ.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#DataStructures.reset!-Tuple{AdaptationUnifRW}","page":"Index","title":"DataStructures.reset!","text":"reset!(adpt::AdaptationUnifRW)\n\nReset the number of proposals and accepted samples to zero.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#Distributions.logpdf-Tuple{UniformRandomWalk,Any,Any}","page":"Index","title":"Distributions.logpdf","text":"Distributions.logpdf(rw::UniformRandomWalk, θ, θ°)\n\nEvaluate the log-probability density function for a move of a random walker from θ to θ°.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._AdaptationUnifRW-Union{Tuple{N}, Tuple{Any,Val{:scalar},Val{N},Any,Any}} where N","page":"Index","title":"ExtensibleMCMC._AdaptationUnifRW","text":"_AdaptationUnifRW(\n        ::Any, ::Val{:scalar}, ::Val{N}, trgt_ar, steps; kwargs...\n    ) where N\n\nInternal constructor of AdaptationUnifRW, populating entries with scalars.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._AdaptationUnifRW-Union{Tuple{N}, Tuple{Val{false},Val{:nonscalar},Val{N},Any,Any}} where N","page":"Index","title":"ExtensibleMCMC._AdaptationUnifRW","text":"_AdaptationUnifRW(\n        ::Val{false}, ::Val{:nonscalar}, v::Val{N}, trgt_ar, steps; kwargs...\n    ) where N\n\nInternal constructor of AdaptationUnifRW, populating entries with SVectors.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._AdaptationUnifRW-Union{Tuple{N}, Tuple{Val{true},Val{:nonscalar},Val{N},Any,Any}} where N","page":"Index","title":"ExtensibleMCMC._AdaptationUnifRW","text":"_AdaptationUnifRW(\n        ::Val{true}, ::Val{:nonscalar}, ::Val{N}, trgt_ar, steps; kwargs...\n    ) where N\n\nInternal constructor of AdaptationUnifRW, populating entries with vectors.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.__run!-NTuple{5,Any}","page":"Index","title":"ExtensibleMCMC.__run!","text":"__run!(global_ws, local_wss, updates, schedule, callbacks)\n\nInternal loops that run the (already initialized) MCMC sampler. global_ws and local_wss are the already initialized global workspace and local workspaces (one for each update) respectively. schedule is the iterator over MCMC steps and callbacks is a list of callbacks.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._adpt_rw_fill_defaults-Tuple{Any}","page":"Index","title":"ExtensibleMCMC._adpt_rw_fill_defaults","text":"_adpt_rw_fill_defaults(N; kwargs...)\n\nReturn a vector with set vector parameters, falling back on default values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._adpt_rw_fill_defaults-Tuple{Function}","page":"Index","title":"ExtensibleMCMC._adpt_rw_fill_defaults","text":"_adpt_rw_fill_defaults(f::Function)\n\nReturn a vector with set parameters, setting them according to the \"recipe\" f, falling back on default values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._adpt_rw_fill_defaults-Tuple{}","page":"Index","title":"ExtensibleMCMC._adpt_rw_fill_defaults","text":"_adpt_rw_fill_defaults(; kwargs...)\n\nReturn a vector with set scalar parameters, falling back on default values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._adpt_rw_fill_defaults-Union{Tuple{Val{N}}, Tuple{N}} where N","page":"Index","title":"ExtensibleMCMC._adpt_rw_fill_defaults","text":"_adpt_rw_fill_defaults(N; kwargs...)\n\nReturn a vector with set SVector parameters, falling back on default values if necessary.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._assure_scalar-Tuple{Any}","page":"Index","title":"ExtensibleMCMC._assure_scalar","text":"_assure_scalar(v)\n\nAccept a scalar or a vector of length one and return it as a scalar. Raise assertion error if other objects are passed.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._upgrade_to_svec-Union{Tuple{N}, Tuple{Any,Val{N}}} where N","page":"Index","title":"ExtensibleMCMC._upgrade_to_svec","text":"_upgrade_to_svec(v, ::Val{N}) where N\n\nReceive a scalar or a vector of length 1 and return a length N static vector of repeats of entry v.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC._upgrade_to_vec-Tuple{Any,Any}","page":"Index","title":"ExtensibleMCMC._upgrade_to_vec","text":"_upgrade_to_vec(v, N)\n\nReceive a scalar or a vector of length 1 and return a length N vector of repeats of entry v.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.accept_reject!","page":"Index","title":"ExtensibleMCMC.accept_reject!","text":"accept_reject!(updt, global_ws, ws, step, i=1)\n\nFinish computations of the log-likelihood ratio between the target and proposal in MH acceptance probability and accept/reject respectively.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.acceptance_rate!-Tuple{AdaptationUnifRW}","page":"Index","title":"ExtensibleMCMC.acceptance_rate!","text":"acceptance_rate!(adpt::AdaptationUnifRW)\n\nDestructive computation of a current acceptance rate that also resets the number of proposals and accepted samples to zeros.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.acceptance_rate-Tuple{AdaptationUnifRW}","page":"Index","title":"ExtensibleMCMC.acceptance_rate","text":"acceptance_rate(adpt::AdaptationUnifRW)\n\nCompute current acceptance rate of the Metropolis-Hastings update step\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.check_if_execute-Tuple{SavingCallback,Any,ExtensibleMCMC.PreMCMCStep}","page":"Index","title":"ExtensibleMCMC.check_if_execute","text":"check_if_execute(callback::SavingCallback, iter)\n\nReturn true if the mcmc iteration iter is one at which an intermediate save is to be made.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.cleanup!-Tuple{SavingCallback,ExtensibleMCMC.GlobalWorkspace,Any,Any}","page":"Index","title":"ExtensibleMCMC.cleanup!","text":"cleanup!(callback::SavingCallback, ws::GlobalWorkspace, iter)\n\nSave the entire MCMC chain, history of proposals, acceptance history etc.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.compute_ll!-Tuple{ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.LocalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.compute_ll!","text":"compute_ll!(\n    global_ws::GlobalWorkspace,\n    ws::LocalWorkspace,\n    step,\n)\n\nEvaluate the proposal log-likelihood at the observations.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.compute_δ-Tuple{Any,Any}","page":"Index","title":"ExtensibleMCMC.compute_δ","text":"compute_δ(p, mcmc_iter)\n\nδ decreases roughly proportional to scale/sqrt(iteration)\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.compute_ϵ","page":"Index","title":"ExtensibleMCMC.compute_ϵ","text":"compute_ϵ(ϵ_old, p, a_r, δ, flip=1.0, f=identity, finv=identity)\n\nϵ is moved by δ to adapt to target acceptance rate\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.custom_zero-Union{Tuple{elT}, Tuple{T}, Tuple{T,Type{elT}}} where elT where T","page":"Index","title":"ExtensibleMCMC.custom_zero","text":"custom_zero(x::T, ::Type{elT}) where {T,elT}\n\nCreate a zero with eltype elT, that is of the same structure as the collection x.\n\nExamples\n\njulia> custom_zero(3.0, Bool)\nfalse\njulia> custom_zero([3.0, 4.0], Bool)\n2-element Array{Bool,1}:\n 0\n 0\njulia> custom_zero(SVector{2}(1, 2), ComplexF64)\n2-element SArray{Tuple{2},Complex{Float64},1,2} with indices SOneTo(2):\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.data_to_csv-Tuple{Any,ExtensibleMCMC.GlobalWorkspace,Any,Any}","page":"Index","title":"ExtensibleMCMC.data_to_csv","text":"data_to_csv(f, ws::GlobalWorkspace, i)\n\nWrite data entries to a CSV file.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.execute!-Tuple{SavingCallback,ExtensibleMCMC.GlobalWorkspace,Any,Any,Any}","page":"Index","title":"ExtensibleMCMC.execute!","text":"execute!(sc::SavingCallback, ws::GlobalWorkspace, iter)\n\nSave the chain of accepted states, proposed states and acceptance history to the disk.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.find_available_name","page":"Index","title":"ExtensibleMCMC.find_available_name","text":"find_available_name(path, filename, disambig_num, extension=\".csv\")\n\nCheck if a chosen filename already exists, if so, then tries appending consecutive numbers to the end of the file until the first one that is not used yet is found.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.find_starting_idx-Tuple{SavingCallback,Any}","page":"Index","title":"ExtensibleMCMC.find_starting_idx","text":"find_starting_idx(callback::SavingCallback, iter)\n\nFind the last index for which saving was done.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.init!","page":"Index","title":"ExtensibleMCMC.init!","text":"init!(\n    mcmc::MCMC,\n    num_mcmc_steps,\n    data,\n    θinit,\n    exclude_updates=[];\n    kwargs...\n)\n\nInitialize the schedule and the global workspace of the MCMC sampler for a given set of updates (already saved in mcmc.updates), a total number of MCMC iterations given by num_mcmc_steps, observed dataset data. θinit is the initial value of the main parameter that the MCMC sampling is done for, exclude_updates lists the update indices and the repspective ranges of mcmc iterations from which these updates are supposed to be omitted from and kwargs lists all additional named arguments passed for creating a global workspace.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.init!-Tuple{SavingCallback,ExtensibleMCMC.GlobalWorkspace}","page":"Index","title":"ExtensibleMCMC.init!","text":"init!(callback::SavingCallback)\n\nCreate a CSV file for writing into.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.init_global_workspace-Union{Tuple{T}, Tuple{ExtensibleMCMC.MCMCBackend,Any,Array{#s16,1} where #s16<:ExtensibleMCMC.MCMCUpdate,Any,Array{T,1}}} where T","page":"Index","title":"ExtensibleMCMC.init_global_workspace","text":"init_global_workspace(\n    ::MCMCBackend,\n    num_mcmc_steps,\n    updates::Vector{<:MCMCUpdate},\n    data,\n    θinit::Vector{T};\n    kwargs...\n) where T\n\nInitialize the <custom>GlobalWorkspace. <custom>MCMCBackend points to which GlobalWorkspace constructors to use, updates is a list of MCMC updates, θinit is the initial guess for the parameter and kwargs are the named arguments passed to run!.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.isequal_except-Union{Tuple{S}, Tuple{T}, Tuple{AdaptationUnifRW{T},AdaptationUnifRW{S},Vararg{Any,N} where N}} where S where T","page":"Index","title":"ExtensibleMCMC.isequal_except","text":"isequal_except(\n    ::AdaptationUnifRW{T}, b::AdaptationUnifRW{S}, args...\n    ) where{T,S}\n\nConvenience comparison of AdaptationUnifRW instances. Used only for tests. The fields specified by args are excluded from comparison.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.log_prior-Tuple{ExtensibleMCMC.Previous,ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.LocalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.log_prior","text":"log_prior(::Previous, updt::MCMCParamUpdate, ws::LocalWorkspace, i)\n\nEvaluate the log-prior at θ.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.log_prior-Tuple{ExtensibleMCMC.Proposal,ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.LocalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.log_prior","text":"log_prior(::Proposal, updt::MCMCParamUpdate, ws::LocalWorkspace, i)\n\nEvaluate the log-prior at θ°.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.log_transition_density-Tuple{ExtensibleMCMC.Previous,ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.LocalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.log_transition_density","text":"log_transition_density(\n    ::Previous, updt::MCMCParamUpdate, ws::LocalWorkspace, i\n)\n\nEvaluate the log-density for a transition θ → θ°.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.log_transition_density-Tuple{ExtensibleMCMC.Proposal,ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.LocalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.log_transition_density","text":"log_transition_density(\n    ::Proposal, updt::MCMCParamUpdate, ws::LocalWorkspace, i\n)\n\nEvaluate the log-density for a transition θ° → θ.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.logit","page":"Index","title":"ExtensibleMCMC.logit","text":"logit(x, a=1.0)\n\nLogit function. (Inverse of sigmoid).\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.readjust!-Tuple{UniformRandomWalk,AdaptationUnifRW,Any}","page":"Index","title":"ExtensibleMCMC.readjust!","text":"readjust!(rw::UniformRandomWalk, adpt::AdaptationUnifRW, mcmc_iter)\n\nAdaptive readjustment of the range for sampling uniforms by the random walker.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.register!-Tuple{Any,AdaptationUnifRW,Bool,Any}","page":"Index","title":"ExtensibleMCMC.register!","text":"register!(adpt::AdaptationUnifRW, accepted::Bool, ::Any)\n\nRegister the result of the acceptance decision in the Metropolis-Hastings step.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.register_accept_reject_results!","page":"Index","title":"ExtensibleMCMC.register_accept_reject_results!","text":"register_accept_reject_results!(\n    accepted::Bool, updt, ws::LocalWorkspace, step, i=1\n)\n\nRegister the results of accept/reject step relevant to a local workspace.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.register_accept_reject_results!","page":"Index","title":"ExtensibleMCMC.register_accept_reject_results!","text":"register_accept_reject_results!(\n    accepted::Bool,\n    updt,\n    global_ws::GlobalWorkspace,\n    local_ws::LocalWorkspace,\n    step,\n    i=1\n)\n\nRegister the result of accept/reject step.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.remove_curly-Union{Tuple{Type{K}}, Tuple{K}} where K","page":"Index","title":"ExtensibleMCMC.remove_curly","text":"remove_curly(::Type{K}) where K\n\nUtility function that removes all type-specifiers listed in the curly brackets.\n\nExamples\n\njulia> remove_curly(Array{Float64,1})\nArray\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.reschedule!","page":"Index","title":"ExtensibleMCMC.reschedule!","text":"reschedule!(\n    schedule::MCMCSchedule,\n    num_new_updates=0,\n    idxes_to_remove=[],\n    idxes_to_add=[]\n)\n\nMake changes to the schedule (possibly in the midst of iterating through it). Add num_new_updtes-many allowable updates that can be performed at each MCMC step, idxes_to_remove lists all parameter udpates that are to be completely removed from the MCMC sampler, idxes_to_add lists entries that are to be added to schedule.exclude_updates.\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.set_proposal!-Tuple{ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.LocalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.set_proposal!","text":"set_proposal!(\n    updt::MCMCParamUpdate,\n    global_ws::GlobalWorkspace,\n    ws::LocalWorkspace,\n    step\n)\n\nThe proposal parameter θ° has been sampled by this point. This function propagates it through workspaces and sets the new parameter in proposal law P°\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.sigmoid","page":"Index","title":"ExtensibleMCMC.sigmoid","text":"sigmoid(x, a=1.0)\n\nSigmoid function. (Inverse of logit).\n\n\n\n\n\n","category":"function"},{"location":"module_index/#ExtensibleMCMC.state-Tuple{ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.MCMCParamUpdate}","page":"Index","title":"ExtensibleMCMC.state","text":"state(ws::GlobalWorkspace, updt::MCMCParamUpdate)\n\nReturn a substate of a gloabl state consisting of coordinates that the updt is concerned with.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.strip_decorators-Tuple{Any}","page":"Index","title":"ExtensibleMCMC.strip_decorators","text":"strip_decorators(updt_and_decor)\n\nRemove all decorators from a list\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.time_to_update-Tuple{Val{true},AdaptationUnifRW}","page":"Index","title":"ExtensibleMCMC.time_to_update","text":"time_to_update(adpt::AdaptationUnifRW)\n\nReturn true if it's the time to update the ϵ parameter of Uniform random walks\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.transition-Tuple{ExtensibleMCMC.MCMCSchedule,Any}","page":"Index","title":"ExtensibleMCMC.transition","text":"transition(schedule::MCMCSchedule, state)\n\nDetermine the next state of the MCMCSchedule iterator, by skipping through all updates that are to be excluded, as per schedule.exclude_updates.\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.update!-Tuple{ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.LocalWorkspace,Any}","page":"Index","title":"ExtensibleMCMC.update!","text":"update!(\n    updt::MCMCParamUpdate,\n    global_ws::GlobalWorkspace,\n    ws::LocalWorkspace,\n    step,\n)\n\nGeneral recipe for performing parameter update (doing an update of the main state of the MCMC sampler).\n\n\n\n\n\n","category":"method"},{"location":"module_index/#ExtensibleMCMC.update_workspaces!-Tuple{ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.LocalWorkspace,Any,Any}","page":"Index","title":"ExtensibleMCMC.update_workspaces!","text":"update_workspaces!(\n    local_updt::MCMCParamUpdate,\n    global_ws::GlobalWorkspace,\n    local_ws::LocalWorkspace,\n    step,\n    prev_ws,\n)\n\nTransfer all the information that is needed at the time of starting the MCMC update step from the global (or a previously used local) to the currently used local workspace.\n\n\n\n\n\n","category":"method"},{"location":"manual/priors/#Defining-custom-priors-1","page":"Priors","title":"Defining custom priors","text":"","category":"section"},{"location":"get_started/basic_use/#get_started-1","page":"Get started","title":"Overview of ExtensibleMCMC.jl's basic functionality","text":"","category":"section"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"For simplest problems all that needs to be provided by the user is a target law, a function that sets the parameters of the target law and a function that evaluates the log-likelihood at the observations. The remaining options can be chosen from a set of objects already pre-defined in this package. Let's look at an example.","category":"page"},{"location":"get_started/basic_use/#Estimating-the-mean-of-a-bivariate-Guassian-1","page":"Get started","title":"Estimating the mean of a bivariate Guassian","text":"","category":"section"},{"location":"get_started/basic_use/#Defining-the-target-law-1","page":"Get started","title":"Defining the target law","text":"","category":"section"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"In this folder we have already defined some examples of the targets laws and a Gaussian law (with a possibility to estimate its mean and covariance matrix) is one of them. For the pedagogical purposes we define the new BivariateGaussian struct below.","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"We start from defining the target law.","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"using Distributions\nusing ExtensibleMCMC\nconst eMCMC = ExtensibleMCMC\n\nmutable struct BivariateGaussian{T}\n    P::T\n    function BivariateGaussian(μ, Σ)\n        @assert length(μ) == 2 && size(Σ) == (2,2)\n        P = MvNormal(μ, Σ)\n        new{typeof(P)}(P)\n    end\nend","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"We must provide two functions for it. The first one is a setter of new parameters","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"function eMCMC.set_parameters!(gsn::BivariateGaussian, loc2glob_idx, θ)\n    μ, Σ = params(gsn.P)\n    μ[loc2glob_idx] .= θ\n    gsn.P = MvNormal(μ, Σ)\nend","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"where loc2glob_idx is a vector of indices pointing to parameters that are to be updated. The second one evaluates the log-likelihood:","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"function Distributions.loglikelihood(gsn::BivariateGaussian, observs)\n    ll = 0.0\n    for obs in observs\n        ll += logpdf(gsn.P, obs)\n    end\n    ll\nend","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"And we're good to go.","category":"page"},{"location":"get_started/basic_use/#Generating-the-data-1","page":"Get started","title":"Generating the data","text":"","category":"section"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"We may simulate some test data. The important point is that unless you overload the update functions yourself, the data should be stored in the format of a NamedTuple with fields P containing the target law and obs with a vector of observations.","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"using Random\nRandom.seed!(10)\nμ, Σ = [1.0, 2.0], [1.0 0.5; 0.5 1.0]\ntrgt = MvNormal(μ, Σ)\nnum_obs = 10\n\ndata = (\n    P = BivariateGaussian(rand(2), Σ),\n    obs = [rand(trgt) for _ in 1:num_obs],\n)","category":"page"},{"location":"get_started/basic_use/#Parametrizing-the-MCMC-sampler-1","page":"Get started","title":"Parametrizing the MCMC sampler","text":"","category":"section"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"Parametrizing the Monte Carlo sampler boils down to specifying a list of updates (out of a list provided in this package plus additional updates defined by you) passed as a vector to an MCMC struct. Each update usually contains","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"specification of a transition kernel\nan index or indices of a parameter vector that is/are being updated\na corresponding prior on the parameters\nadditional information about adaptation scheme","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"Additionally, we may pass a backend to MCMC to specify what type of Workspaces need to be initialized. For now we will not use any adaptation and we will use a default backend.","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"Apart from MCMC struct we need to pass the number of mcmc steps, the data and an initial guess for an unknown parameter vector.","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"Finally, we have an option to pass Callbacks. For now let's leave these empty. We will discuss them in detail in (...).","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(UniformRandomWalk([1.0]), [1]; prior=ImproperPrior()),\n            RandomWalkUpdate(UniformRandomWalk([1.0]), [2]; prior=ImproperPrior()),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)","category":"page"},{"location":"get_started/basic_use/#Running-the-sampler-1","page":"Get started","title":"Running the sampler","text":"","category":"section"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"With parameterization of the sampler in place, running it is a one-liner","category":"page"},{"location":"get_started/basic_use/#","page":"Get started","title":"Get started","text":"workspace = run!(mcmc_params...)","category":"page"},{"location":"manual/workspaces/#The-idea-behind-Workspaces-1","page":"Workspaces","title":"The idea behind Workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Markov chain Monte Carlo algorithms often involve computationally expensive routines. As these often need to be repeated at each MCMC iteration, the MCMC algorithm may be sped up significantly by pre-allocating suitable containers on which all or a majority of the computations are to be performed. In ExtensibleMCMC.jl these containers are termed Workspaces.","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"There are two types of Workspaces:","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"GlobalWorkspaces and\nLocalWorkspaces","category":"page"},{"location":"manual/workspaces/#Workspaces-inheriting-from-GlobalWorkspace-1","page":"Workspaces","title":"Workspaces inheriting from GlobalWorkspace","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"GlobalWorkspace, is the master Workspace that is responsible for:","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"keeping track of the MCMC chain, in particular the most recent state of the chain\nholding the observed data (or at least a pointer to it)","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"and optionally:","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"holding containers for doing computations\nkeeping track of some online statistics regarding the chain\nany other object that conceptually belongs to the scope of the chain and not the scope of the local MCMC updates","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"We implement a generic version of GlobalWorkspace that may be suitable for simple problems. For more advanced problems the user will need to implement custom GlobalWorkspaces.","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.GenericGlobalWorkspace","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.GenericGlobalWorkspace","page":"Workspaces","title":"ExtensibleMCMC.GenericGlobalWorkspace","text":"struct GenericGlobalWorkspace{T,TD,TL} <: GlobalWorkspace{T}\n    sub_ws::StandardGlobalSubworkspace{T,TD}\n    P::TL\n    P°::TL\nend\n\nGeneric global workspace with sub_ws containing current state and keeping track of its history and some basic statistics. P and P° are the target laws with accepted and proposal state set as parameters.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"where","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.StandardGlobalSubworkspace","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.StandardGlobalSubworkspace","page":"Workspaces","title":"ExtensibleMCMC.StandardGlobalSubworkspace","text":"struct StandardGlobalSubworkspace{T,TD} <: GlobalWorkspace{T}\n    state::Vector{T}\n    state_history::Vector{Vector{Vector{T}}}\n    state_proposal_history::Vector{Vector{Vector{T}}}\n    data::TD\n    stats::GenericChainStats{T}\nend\n\nStandard containers expected to be present in every global workspace. state is the currently accepted parameter θ, state_history is a chain of states that have been accepted and state_proposal_history is a chain of states that have been proposed. data are the data passed to an MCMC sampler (usually just a pointer) and stats gathers some basic online information about the chain.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"tip: Tip\nTo see an example of an implementation of a custom Workspace see DiffusionMCMC.jl, where we implemented DiffusionGlobalWorkspace (and DiffusionLocalWorkspace).","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"note: Note\nStandardGlobalSubworkspace is simply a collection of the most common fields present in GlobalWorkspace. As such, it doesn't need to be present in custom implementations of GlobalWorkspace, however, it will often be convenient to do so.","category":"page"},{"location":"manual/workspaces/#Workspaces-inheriting-from-LocalWorkspace-1","page":"Workspaces","title":"Workspaces inheriting from LocalWorkspace","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Each MCMC update (for instance RandomWalkUpdate) will have its own LocalWorkspace. During updates it will have access to both its LocalWorkspace as well as the GlobalWorkspace, but it will not see LocalWorkspaces of other updates (however, information between LocalWorkspaces may be exchanged prior to each update call). Conceptually, the objects that fall under LocalWorkspace are those that","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"belong only to a local scope (for instance, proposal ϑ° for a subset ϑ of all parameters θ, or the ∇log-likelihood)\nprovide appropriately shaped views to a global view (for instance, a view to a subset of observations that are to be used for computations in this update, or a recipe for how to sub-sample the observations)","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Similarly to GenericGlobalWorkspace, we implement a generic version of LocalWorkspace suitable for simple problems. See DiffusionMCMC.jl for a more advanced example.","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.GenericLocalWorkspace","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.GenericLocalWorkspace","page":"Workspaces","title":"ExtensibleMCMC.GenericLocalWorkspace","text":"struct GenericLocalWorkspace{T} <: LocalWorkspace{T}\n    sub_ws::StandardLocalSubworkspace{T}\n    sub_ws°::StandardLocalSubworkspace{T}\n    acceptance_history::Vector{Bool}\nend\n\nGeneric local workspace with sub_ws containing a subset of state that the corresponding updates operates on, with currently accepted value of state as well as its log-likelihood. sub_ws° corresponds to a proposal state. acceptance_history keeps track of accept/reject decisions.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"where","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.StandardLocalSubworkspace","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.StandardLocalSubworkspace","page":"Workspaces","title":"ExtensibleMCMC.StandardLocalSubworkspace","text":"struct StandardLocalSubworkspace{T} <: LocalWorkspace{T}\n    state::Vector{T}\n    ll::Vector{Float64}\n    ll_history::Vector{Vector{Float64}}\n    ∇ll::Vector{Vector{Float64}}\n    momentum::Vector{Float64}\nend\n\nStandard containers likely to be present in every local workspace. state is the currently accepted subset of parameter θ that the corresponding update operates on, ll is the corresponding log-likelihood and ll_history is the chain of log-likelihoods. A single ll is of the type Vector{Float64} to reflect the fact that a problem might admit a natural factorisation into independent components that may be operated on independently, in parallel with each entry in ll corresponding to a separate component. ∇ll is the gradient of log-likelihood (needed by gradient-based algorithms) and momentum is the variable needed for the Hamiltionan dynamics. ∇ll and momentum may be simply left untouched if the problem does not need them.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#Custom-Workspaces-1","page":"Workspaces","title":"Custom Workspaces","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"One of the most important aspects of ExtensibleMCMC.jl is customizability of Workspaces. Below, we describe how to define your own Workspaces.","category":"page"},{"location":"manual/workspaces/#Custom-GlobalWorkspace-1","page":"Workspaces","title":"Custom GlobalWorkspace","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Each <CUSTOM>GlobalWorskspace needs to inherit from GlobalWorkspace.","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.GlobalWorkspace","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.GlobalWorkspace","page":"Workspaces","title":"ExtensibleMCMC.GlobalWorkspace","text":"GlobalWorkspace{T} <: Workspace\n\nSupertype of all global workspaces. Each MCMC sampler must have a unique global workspace, which contains state, state_history, state_proposal_history, acceptance_history and data. state is the paramater vector that the MCMC sampling is done for (other names being self-explanatory).\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Apart from struct definition we need to provide a <CUSTOM>Backend inheriting from:","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.MCMCBackend","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.MCMCBackend","page":"Workspaces","title":"ExtensibleMCMC.MCMCBackend","text":"MCMCBackend\n\nSupertype of all backends for the MCMC sampler.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"that will help Julia choose suitable initializers.","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Additionally, if you plan on re-using some components of ExtensibleMCMC.jl, then the following methods MUST be defined for your <CUSTOM>GlobalWorskspace (using  <CUSTOM>GlobalWorskspace in place of GlobalWorkspace and <CUSTOM>Backend in place of MCMCBackend):","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.init_global_workspace(\n    ::ExtensibleMCMC.MCMCBackend,\n    schedule::ExtensibleMCMC.MCMCSchedule,\n    updates::Vector{<:ExtensibleMCMC.MCMCUpdate},\n    data,\n    θinit::Vector{T};\n    kwargs...\n) where T\nExtensibleMCMC.loglikelihood(ws::ExtensibleMCMC.GlobalWorkspace, ::ExtensibleMCMC.Proposal)\nExtensibleMCMC.loglikelihood(ws::ExtensibleMCMC.GlobalWorkspace, ::ExtensibleMCMC.Previous)\n","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.init_global_workspace-Union{Tuple{T}, Tuple{ExtensibleMCMC.MCMCBackend,ExtensibleMCMC.MCMCSchedule,Array{#s1,1} where #s1<:ExtensibleMCMC.MCMCUpdate,Any,Array{T,1}}} where T","page":"Workspaces","title":"ExtensibleMCMC.init_global_workspace","text":"init_global_workspace(\n    ::MCMCBackend,\n    num_mcmc_steps,\n    updates::Vector{<:MCMCUpdate},\n    data,\n    θinit::Vector{T};\n    kwargs...\n) where T\n\nInitialize the <custom>GlobalWorkspace. <custom>MCMCBackend points to which GlobalWorkspace constructors to use, updates is a list of MCMC updates, θinit is the initial guess for the parameter and kwargs are the named arguments passed to run!.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#StatsBase.loglikelihood-Tuple{ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.Proposal}","page":"Workspaces","title":"StatsBase.loglikelihood","text":"loglikelihood(ws::GlobalWorkspace, ::Proposal)\n\nEvaluate the loglikelihood for the proposal Law and observations stored in a global workspace.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#StatsBase.loglikelihood-Tuple{ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.Previous}","page":"Workspaces","title":"StatsBase.loglikelihood","text":"loglikelihood(ws::GlobalWorkspace, ::Previous)\n\nEvaluate the loglikelihood for the accepted Law and observations stored in a global workspace.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"note: Note\nWhen you are overriding loglikelihood, then do so via StatsBase.jl or Distributions.jl , where the function name originally belongs to, i.e.:using StatsBase\nconst eMCMC = ExtensibleMCMC\nStatsBase.loglikelihood(ws::CUSTOMGlobalWorkspace, ::eMCMC.Proposal) = ...\nStatsBase.loglikelihood(ws::CUSTOMGlobalWorkspace, ::eMCMC.Previous) = ...","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"If <CUSTOM>GlobalWorskspace contains a field sub_ws::StandardGlobalSubworkspace, then the methods below will work automatically. If it does not, then you should implement them for your <CUSTOM>GlobalWorskspace:","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.num_mcmc_steps(ws::ExtensibleMCMC.GlobalWorkspace)\nExtensibleMCMC.state(ws::ExtensibleMCMC.GlobalWorkspace)\nExtensibleMCMC.state(ws::ExtensibleMCMC.GlobalWorkspace, step)\nExtensibleMCMC.state°(ws::ExtensibleMCMC.GlobalWorkspace, step)\nExtensibleMCMC.num_updt(ws::ExtensibleMCMC.GlobalWorkspace)\nExtensibleMCMC.estim_mean(ws::ExtensibleMCMC.GlobalWorkspace)\nExtensibleMCMC.estim_cov(ws::ExtensibleMCMC.GlobalWorkspace)","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.num_mcmc_steps-Tuple{ExtensibleMCMC.GlobalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.num_mcmc_steps","text":"num_mcmc_steps(ws::GlobalWorkspace)\n\nReturn the total set number of MCMC iterations.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.state-Tuple{ExtensibleMCMC.GlobalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.state","text":"state(ws::GlobalWorkspace)\n\nReturn currently accepted state of the chain.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.state-Tuple{ExtensibleMCMC.GlobalWorkspace,Any}","page":"Workspaces","title":"ExtensibleMCMC.state","text":"state(ws::GlobalWorkspace, step)\n\nReturn the state of the chain accepted at the the step iteration of the Markov chain.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.state°-Tuple{ExtensibleMCMC.GlobalWorkspace,Any}","page":"Workspaces","title":"ExtensibleMCMC.state°","text":"state°(ws::GlobalWorkspace, step)\n\nReturn the state of the chain proposed at the the step iteration of the Markov chain.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.num_updt-Tuple{ExtensibleMCMC.GlobalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.num_updt","text":"num_updt(ws::GlobalWorkspace)\n\nReturn the total set number of MCMC updates that may be performed at each MCMC iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.estim_mean-Tuple{ExtensibleMCMC.GlobalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.estim_mean","text":"estim_mean(ws::GlobalWorkspace)\n\nReturn the empirical mean of the parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.estim_cov-Tuple{ExtensibleMCMC.GlobalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.estim_cov","text":"estim_cov(ws::GlobalWorkspace)\n\nReturn the empirical covariance of the parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#Custom-LocalWorkspace-1","page":"Workspaces","title":"Custom LocalWorkspace","text":"","category":"section"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Each <CUSTOM>LocalWorskspace needs to inherit from LocalWorkspace.","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.LocalWorkspace","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.LocalWorkspace","page":"Workspaces","title":"ExtensibleMCMC.LocalWorkspace","text":"LocalWorkspace{T} <: Workspace\n\nSupertype of all local workspaces. Local workspace should contain any additional gathering of objects that are needed by specific updates, but are not are not already in a global workspace. Each MCMC update has its own LocalWorkspace.\n\n\n\n\n\n","category":"type"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Additionally, if you plan on re-using some components of ExtensibleMCMC.jl, then the following methods MUST be defined for your <CUSTOM>LocalWorskspace (using  <CUSTOM>LocalWorskspace in place of LocalWorkspace):","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.create_workspace(\n    ::ExtensibleMCMC.MCMCBackend,\n    mcmcupdate,\n    global_ws::ExtensibleMCMC.GlobalWorkspace,\n    num_mcmc_steps\n) where {T}\nExtensibleMCMC.accepted(ws::ExtensibleMCMC.LocalWorkspace, i::Int)\nExtensibleMCMC.set_accepted!(ws::ExtensibleMCMC.LocalWorkspace, i::Int, v)","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.create_workspace-Union{Tuple{T}, Tuple{ExtensibleMCMC.MCMCBackend,Any,ExtensibleMCMC.GlobalWorkspace,Any}} where T","page":"Workspaces","title":"ExtensibleMCMC.create_workspace","text":"create_workspace(\n    ::MCMCBackend,\n    mcmcupdate,\n    global_ws::GlobalWorkspace,\n    num_mcmc_steps\n) where {T}\n\nCreate a local workspace for a given mcmcupdate.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.accepted-Tuple{ExtensibleMCMC.LocalWorkspace,Int64}","page":"Workspaces","title":"ExtensibleMCMC.accepted","text":"accepted(ws::LocalWorkspace, i::Int)\n\nReturn boolean for whether the ith update has been accepted.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.set_accepted!-Tuple{ExtensibleMCMC.LocalWorkspace,Int64,Any}","page":"Workspaces","title":"ExtensibleMCMC.set_accepted!","text":"set_accepted!(ws::LocalWorkspace, i::Int, v)\n\nSet boolean for whether the ith update has been accepted.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"If your <CUSTOM>LocalWorskspace contains sub_ws::StandardGlobalSubworkspace and sub_ws°::StandardGlobalSubworkspace as its fields then the methods below will work automatically:","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.ll(ws::ExtensibleMCMC.LocalWorkspace)\nExtensibleMCMC.ll°(ws::ExtensibleMCMC.LocalWorkspace)\nExtensibleMCMC.ll(ws::ExtensibleMCMC.LocalWorkspace, i::Int)\nExtensibleMCMC.ll°(ws::ExtensibleMCMC.LocalWorkspace, i::Int)\nExtensibleMCMC.state(ws::ExtensibleMCMC.LocalWorkspace)\nExtensibleMCMC.state°(ws::ExtensibleMCMC.LocalWorkspace)","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.ll-Tuple{ExtensibleMCMC.LocalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.ll","text":"ll(ws::LocalWorkspace)\n\nReturn log-likelihood of the currently accepted parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.ll°-Tuple{ExtensibleMCMC.LocalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.ll°","text":"ll°(ws::LocalWorkspace)\n\nReturn log-likelihood of the currently proposed parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.ll-Tuple{ExtensibleMCMC.LocalWorkspace,Int64}","page":"Workspaces","title":"ExtensibleMCMC.ll","text":"ll(ws::LocalWorkspace, i::Int)\n\nReturn log-likelihood of the ith accepted parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.ll°-Tuple{ExtensibleMCMC.LocalWorkspace,Int64}","page":"Workspaces","title":"ExtensibleMCMC.ll°","text":"ll°(ws::LocalWorkspace, i::Int)\n\nReturn log-likelihood of the ith proposed parameter.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.state-Tuple{ExtensibleMCMC.LocalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.state","text":"state(ws::LocalWorkspace)\n\nReturn the last accepted state.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.state°-Tuple{ExtensibleMCMC.LocalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.state°","text":"state°(ws::LocalWorkspace)\n\nReturn the last proposed state.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"tip: Tip\nThe function names associated with proposals end on a character °, which in Atom can be displayed with \\degree and has a unicode: U+00B0.","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"Finally, there are some functions that are likely to work for custom LocalWorkspaces, but you are advised to check for compatibility:","category":"page"},{"location":"manual/workspaces/#","page":"Workspaces","title":"Workspaces","text":"ExtensibleMCMC.create_workspaces(v::ExtensibleMCMC.MCMCBackend, mcmc::ExtensibleMCMC.MCMC)\nExtensibleMCMC.llr(ws::ExtensibleMCMC.LocalWorkspace, i::Int)\nExtensibleMCMC.name_of_update(ws::ExtensibleMCMC.LocalWorkspace)","category":"page"},{"location":"manual/workspaces/#ExtensibleMCMC.create_workspaces-Tuple{ExtensibleMCMC.MCMCBackend,MCMC}","page":"Workspaces","title":"ExtensibleMCMC.create_workspaces","text":"create_workspaces(v::MCMCBackend, mcmc::MCMC)\n\nCreate local workspaces, one for each update.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.llr-Tuple{ExtensibleMCMC.LocalWorkspace,Int64}","page":"Workspaces","title":"ExtensibleMCMC.llr","text":"llr(ws::LocalWorkspace, i::Int)\n\nCompute log-likelihood ratio at ith mcmc iteration.\n\n\n\n\n\n","category":"method"},{"location":"manual/workspaces/#ExtensibleMCMC.name_of_update-Tuple{ExtensibleMCMC.LocalWorkspace}","page":"Workspaces","title":"ExtensibleMCMC.name_of_update","text":"name_of_update(ws::LocalWorkspace)\n\nReturn the name of the update.\n\n\n\n\n\n","category":"method"},{"location":"how_to_guides/define_my_own_workspace/#How-to-define-my-own-Workspace-1","page":"(TODO) Definy my own workspace","title":"How to define my own Workspace","text":"","category":"section"},{"location":"manual/callbacks/#Callbacks-1","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"Callbacks are instructions that allow for certain interactions with the state of the sampler while the sampler is still working.","category":"page"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"Each concrete implementation of a callback inherits from","category":"page"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"ExtensibleMCMC.Callback","category":"page"},{"location":"manual/callbacks/#ExtensibleMCMC.Callback","page":"Callbacks","title":"ExtensibleMCMC.Callback","text":"Callback\n\nSupertype of all callbacks. They specify additional actions that can be performed before or after each MCMC step or at the very end of sampling.\n\n\n\n\n\n","category":"type"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"This package implements two types of callbacks:","category":"page"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"SavingCallback—for saving intermediate states of the sampler to CSV files\nREPLCallback—for printing progress messages to REPL","category":"page"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"tip: Tip\nSee a companion package ExtensibleMCMCPlots.jl where we additionally implemented a PlottingCallback that does online diagnostic plots that are automatically updated as the chain is being updated.","category":"page"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"note: Note\nTo pass a list of Callbacks to an mcmc sampler pass them in a list to a run! function.","category":"page"},{"location":"manual/callbacks/#Callback-for-printing-progress-messages-to-REPL-1","page":"Callbacks","title":"Callback for printing progress messages to REPL","text":"","category":"section"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"ExtensibleMCMC.REPLCallback","category":"page"},{"location":"manual/callbacks/#ExtensibleMCMC.REPLCallback","page":"Callbacks","title":"ExtensibleMCMC.REPLCallback","text":"struct REPLCallback <: Callback\n    print_every_k_iter::Int64\n    show_all_updates::Bool\n    basic_info_only::Bool\nend\n\nStruct with instructions for printing progress messages to REPL.\n\nREPLCallback(;\n    print_every_k_iter=100,\n    show_all_upates=true,\n    basic_info_only=true,\n)\n\nBase constructor that uses named arguments.\n\n\n\n\n\n","category":"type"},{"location":"manual/callbacks/#Callback-for-saving-intermediate-results-to-CSV-files-1","page":"Callbacks","title":"Callback for saving intermediate results to CSV files","text":"","category":"section"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"ExtensibleMCMC.SavingCallback","category":"page"},{"location":"manual/callbacks/#ExtensibleMCMC.SavingCallback","page":"Callbacks","title":"ExtensibleMCMC.SavingCallback","text":"struct SavingCallback <: Callback\n    save_at_the_end::Bool\n    save_intermediate::Bool\n    save_at_iters::Vector{Int64}\n    filename::String\nend\n\nStruct for saving the intermediate or final states of the sampled chain to a hard drive.\n\nSavingCallback(;\n    save_at_the_end=true,\n    save_at_iters=[],\n    overwrite_at_save=false,\n    filename=\"mcmc_results\",\n    add_datestamp=false,\n    path=\".\",\n)\n\nThe main constructor for SavingCallback. save_at_the_end indicates whether to save to a file at the end of mcmc sampling, save_at_iters specifies at which additional intermediate iterations the chain should be saved to a file, set overwrite to true to overwrite any already existing file that shares the name with the one passed to this function. filename is the main stem of the file's name, add_datestamps will add the date and time at the time of creating the callback to the filename and path specifies the directory path to save to.\n\n\n\n\n\n","category":"type"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"tip: Tip\nIf each iteration of your MCMC sampler is very fast then you should avoid appending to CSV files at each iteration of the MCMC chain to prevent slow-downs. Use save_at_iters to specify the iterations at which to save to CSV files.","category":"page"},{"location":"manual/callbacks/#Writing-custom-callbacks-1","page":"Callbacks","title":"Writing custom callbacks","text":"","category":"section"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"Each custom callback may provide interface for the following methods:","category":"page"},{"location":"manual/callbacks/#","page":"Callbacks","title":"Callbacks","text":"ExtensibleMCMC.init!(\n    ::ExtensibleMCMC.Callback,\n    ws::ExtensibleMCMC.GlobalWorkspace\n)\nExtensibleMCMC.check_if_execute(\n    callback::ExtensibleMCMC.Callback,\n    step,\n    flag\n)\nExtensibleMCMC.execute!(\n    callback::ExtensibleMCMC.Callback,\n    global_ws::ExtensibleMCMC.GlobalWorkspace,\n    local_wss,\n    step,\n    flag\n)\nExtensibleMCMC.cleanup!(\n    callback::ExtensibleMCMC.Callback,\n    ws::ExtensibleMCMC.GlobalWorkspace,\n    step\n)","category":"page"},{"location":"manual/callbacks/#ExtensibleMCMC.init!-Tuple{ExtensibleMCMC.Callback,ExtensibleMCMC.GlobalWorkspace}","page":"Callbacks","title":"ExtensibleMCMC.init!","text":"init!(::Callback, ws::GlobalWorkspace)\n\nInitialization actions for a callback. By default nothing to be done.\n\n\n\n\n\n","category":"method"},{"location":"manual/callbacks/#ExtensibleMCMC.check_if_execute-Tuple{ExtensibleMCMC.Callback,Any,Any}","page":"Callbacks","title":"ExtensibleMCMC.check_if_execute","text":"check_if_execute(callback::Callback, step, flag)\n\nCheck if callback is supposed to be executed at the mcmc step step with pre- post- update flag flag.\n\n\n\n\n\n","category":"method"},{"location":"manual/callbacks/#ExtensibleMCMC.execute!-Tuple{ExtensibleMCMC.Callback,ExtensibleMCMC.GlobalWorkspace,Any,Any,Any}","page":"Callbacks","title":"ExtensibleMCMC.execute!","text":"execute!(\n    callback::Callback,\n    global_ws::GlobalWorkspace,\n    local_wss,\n    step,\n    flag\n)\n\nPerform actions as specified by the callback. local_wss is a vector of all local workspaces, step is an iterator from the MCMCSchedule and flag is either ::PreMCMCStep or ::PostMCMCStep.\n\n\n\n\n\n","category":"method"},{"location":"manual/callbacks/#ExtensibleMCMC.cleanup!-Tuple{ExtensibleMCMC.Callback,ExtensibleMCMC.GlobalWorkspace,Any}","page":"Callbacks","title":"ExtensibleMCMC.cleanup!","text":"cleanup!(callback::Callback, ws::GlobalWorkspace, step)\n\nThe last call to callback, after all MCMC steps and before exiting the function run!.\n\n\n\n\n\n","category":"method"},{"location":"manual/updates_and_decorators/#Updates-1","page":"Updates & Decorators","title":"Updates","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"Updates are structs that hold instructions about the MCMC updates.","category":"page"},{"location":"manual/updates_and_decorators/#Metropolis-Hastings-with-random-walk-proposals-1","page":"Updates & Decorators","title":"Metropolis Hastings with random walk proposals","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"The simplest type of updates are Metropolis-Hastings updates with random walk proposals.","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"ExtensibleMCMC.RandomWalkUpdate","category":"page"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.RandomWalkUpdate","page":"Updates & Decorators","title":"ExtensibleMCMC.RandomWalkUpdate","text":"struct RandomWalkUpdate{TRW,TA,K,TP} <: MCMCParamUpdate\n    rw::TRW\n    adpt::TA\n    coords::K\n    prior::TP\nend\n\nDefinition of an MCMC update that uses Metropolis-Hastings algorithm with random walk proposals. rw is the random walk sampler, adpt is the struct responsible for adaptation of hyperparameters, coords lists the coordinate indeces of the global state that the given update operates on and prior is a prior for this update step (i.e. for a given subset of parameter vector).\n\n    function RandomWalkUpdate(\n        rw::TRW,\n        idx_of_global::K;\n        prior::TP=ImproperPrior(),\n        adpt::TA=NoAdaptation()\n    ) where {TRW<:RandomWalk,K,TA,TP}\n\nBase constructor.\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"The random walk can be any viable distribution, below we present two cases that have been implemented.","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"note: Note\nVery often we only need to update a subset of the parameters as in the Metropolis-within-Gibbs algorithm. This is easily done by specifying the indices of relevant coordinates in idx_of_global field in the constructor.","category":"page"},{"location":"manual/updates_and_decorators/#Uniform-Random-Walker-1","page":"Updates & Decorators","title":"Uniform Random Walker","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"The simplest type of walker is a Uniform random walker. It samples","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"U_isimtextttUnif(-epsilonepsilontexttt)quad iintextttidx_of_global","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"and then, advances each state according to","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"X_i + U_iquad iintextttidx_of_global","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"ExtensibleMCMC.UniformRandomWalk","category":"page"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.UniformRandomWalk","page":"Updates & Decorators","title":"ExtensibleMCMC.UniformRandomWalk","text":"mutable struct UniformRandomWalk{T,S} <: RandomWalk\n    ϵ::T\n    pos::S\nend\n\nA uniform random walker that moves all unrestricted coordinates according to the additive rule xᵢ+U, with U∼Unif(-ϵᵢ,ϵᵢ) and moves all coordinates restricted to be positive according to the rule xᵢexp(U), with U∼Unif(-ϵᵢ,ϵᵢ).\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"note: Note\nIn practice, some coordinates of the parameter vector may be restricted to take only positive values. We may impose this restriction by performing a \"multiplicative exponentiated uniform random walk\" for such coordinates. Such random walk is no longer uniform on the original space, but is uniform in steps for log(X_i).","category":"page"},{"location":"manual/updates_and_decorators/#Adaptation-1","page":"Updates & Decorators","title":"Adaptation","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"The uniform random walker depends on the hyper-parameter ϵ, which has a large effect on the learning speed of the MCMC sampler. This hyper-parameter can be learned adaptively in a standard way, by targeting the acceptance rate of the sampler. To turn the adaptation on we have to pass an appropriately initialized AdaptationUnifRW as a keyword argument adpt:","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"ExtensibleMCMC.AdaptationUnifRW","category":"page"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.AdaptationUnifRW","page":"Updates & Decorators","title":"ExtensibleMCMC.AdaptationUnifRW","text":"mutable struct AdaptationUnifRW{T} <: Adaptation\n    proposed::Int64\n    accepted::Int64\n    target_accpt_rate::Float64\n    adapt_every_k_steps::Int64\n    scale::T\n    min::T\n    max::T\n    offset::T\n    N::Int64\nend\n\nA struct containing information about the way in which to adapt the steps of the uniform random walker. proposed and accepted are the internal counters that keep track of the number of proposed and accepted samples. target_accpt_rate is the acceptance rate of the Metropolis-Hastings steps that is supposed to be targetted. min is used to enforce the minimal allowable range that the random walker can sample from, max enforces the maximum. offset introduces some delay in the start of decelerting the adaptation extent and scale is a scaling parameter for adaptation speed. N is the number of coordinates of the random walker.\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"To see a simple example of a difference that adaptation can make see the Tutorial on estimating the mean of a simple bivariate Gaussian","category":"page"},{"location":"manual/updates_and_decorators/#Gaussian-Random-Walker-1","page":"Updates & Decorators","title":"Gaussian Random Walker","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"Another implemented type of random walker is a Gaussian random walker.","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"ExtensibleMCMC.GaussianRandomWalk","category":"page"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.GaussianRandomWalk","page":"Updates & Decorators","title":"ExtensibleMCMC.GaussianRandomWalk","text":"mutable struct GaussianRandomWalk{T} <: RandomWalk\n    Σ::Symmetric{T,Array{T,2}}\n    pos::Vector{Bool}\nend\n\nA Gaussian random walker that first transforms all coordinates restricted to be positive to a log-scale via log(θᵢ), then moves according to θ°∼N(θ, Σ) and finally transforms the restricted coordinates back to the original scale via exp(θᵢ°). Restrictions are specified in the vector pos (and no restrictions correspond to all entries in pos being false).\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"It can be used for single-site updates as well as joint updates.","category":"page"},{"location":"manual/updates_and_decorators/#Adaptation-2","page":"Updates & Decorators","title":"Adaptation","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"The adaptation of GaussianRandomWalk may no longer be done as in the case of UniformRandomWalk (in principle, with the exception of 1-d, but this is not implemented), as the entire covariance matrix needs to be learnt now. This is instead implemented with Haario-type updates.","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"ExtensibleMCMC.HaarioTypeAdaptation","category":"page"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.HaarioTypeAdaptation","page":"Updates & Decorators","title":"ExtensibleMCMC.HaarioTypeAdaptation","text":"mutable struct HaarioTypeAdaptation{T,TF} <: Adaptation\n    mean::Vector{T}\n    cov::Matrix{T}\n    adapt_every_k_steps::Int64\n    scale::Float64\n    N::Int64\n    M::Int64\n    fλ::TF\nend\n\nA struct containing information about the way in which to adapt the steps of the Gaussian random walker in a scheme: Xᵢ₊₁ = λZ+(1-λ)W, where Z ∼ N(Xᵢ, cI) and W ∼ N(Xᵢ, Σₐ), with Σₐ the covariance matrix that the adaptive scheme aims to learn. mean and cov are the empirical mean and covariance of the (appropriately log-transformed) local state vector. Every adapt_every_k_steps number of steps an adaptation is performed. scale is a scaling for going from the empirical covariance to the covariance of the Gaussian random walker. N is the total number of terms based on which the mean and cov were computed, M is the number of updates since the last call to adaptation and fλ is a function for determining the λ weight.\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"In addition, in order to run HaarioTypeAdaptation, the update transition kernel must be set to GaussianRandomWalkMix instead of just GaussianRandomWalk, for obvious reasons that follow from the description of the former:","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"ExtensibleMCMC.GaussianRandomWalkMix","category":"page"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.GaussianRandomWalkMix","page":"Updates & Decorators","title":"ExtensibleMCMC.GaussianRandomWalkMix","text":"mutable struct GaussianRandomWalkMix{T} <: RandomWalk\n    gsn_A::GaussianRandomWalk{T}\n    gsn_B::GaussianRandomWalk{T}\n    λ::Float64\nend\n\nA mixture of two Gaussian random walkers. It performs updates according to Xᵢ₊₁ = Xᵢ + λZₐ + (1-λ)Zᵦ, where Zₐ ∼ N(0,Σₐ) and Zᵦ ∼ N(0, Σᵦ) (with Xᵢ being already appropriately log-transformed if needed).\n\n\n\n\n\n","category":"type"},{"location":"manual/updates_and_decorators/#Metropolis-adjusted-Langevin-algorithm-(MALA)-1","page":"Updates & Decorators","title":"Metropolis-adjusted Langevin algorithm (MALA)","text":"","category":"section"},{"location":"manual/updates_and_decorators/#Hamiltonian-Monte-Carlo-1","page":"Updates & Decorators","title":"Hamiltonian Monte Carlo","text":"","category":"section"},{"location":"manual/updates_and_decorators/#Custom-MCMC-updates-and-decorators-1","page":"Updates & Decorators","title":"Custom MCMC updates and decorators","text":"","category":"section"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"Each update (that updates parameters) must implement","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"ExtensibleMCMC.log_transition_density(updt::ExtensibleMCMC.MCMCParamUpdate, θ, θ°)\nExtensibleMCMC.proposal!(updt::ExtensibleMCMC.MCMCParamUpdate, global_ws, ws::ExtensibleMCMC.LocalWorkspace, step)\nExtensibleMCMC.set_parameters!(\n    ::ExtensibleMCMC.Proposal,\n    updt::ExtensibleMCMC.MCMCParamUpdate,\n    global_ws::ExtensibleMCMC.GlobalWorkspace,\n    ws::ExtensibleMCMC.LocalWorkspace,\n)\nExtensibleMCMC.set_parameters!(\n    ::ExtensibleMCMC.Previous,\n    updt::ExtensibleMCMC.MCMCParamUpdate,\n    global_ws::ExtensibleMCMC.GlobalWorkspace,\n    ws::ExtensibleMCMC.LocalWorkspace,\n)","category":"page"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.log_transition_density-Tuple{ExtensibleMCMC.MCMCParamUpdate,Any,Any}","page":"Updates & Decorators","title":"ExtensibleMCMC.log_transition_density","text":"log_transition_density(updt::MCMCParamUpdate, θ, θ°)\n\nEvaluates the log-transition density for an update θ → θ°\n\n\n\n\n\n","category":"method"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.proposal!-Tuple{ExtensibleMCMC.MCMCParamUpdate,Any,ExtensibleMCMC.LocalWorkspace,Any}","page":"Updates & Decorators","title":"ExtensibleMCMC.proposal!","text":"proposal!(updt::MCMCParamUpdate, global_ws, ws::LocalWorkspace, step)\n\nSample a proposal value for the MCMC's local state variable.\n\n\n\n\n\n","category":"method"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.set_parameters!-Tuple{ExtensibleMCMC.Proposal,ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.LocalWorkspace}","page":"Updates & Decorators","title":"ExtensibleMCMC.set_parameters!","text":"set_parameters!(\n    ::Proposal,\n    updt::MCMCParamUpdate,\n    global_ws::GlobalWorkspace,\n    ws::LocalWorkspace,\n)\n\nSet the parameters of the proposal Law to the current value held by the proposal state.\n\n\n\n\n\n","category":"method"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.set_parameters!-Tuple{ExtensibleMCMC.Previous,ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.GlobalWorkspace,ExtensibleMCMC.LocalWorkspace}","page":"Updates & Decorators","title":"ExtensibleMCMC.set_parameters!","text":"set_parameters!(\n    ::Previous,\n    updt::MCMCParamUpdate,\n    global_ws::GlobalWorkspace,\n    ws::LocalWorkspace,\n)\n\nSet the parameters of the currently accepted Law to the current value held by the accepted state.\n\n\n\n\n\n","category":"method"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"Additionally, the following methods are implemented, but may be overwritten:","category":"page"},{"location":"manual/updates_and_decorators/#","page":"Updates & Decorators","title":"Updates & Decorators","text":"ExtensibleMCMC.log_prior(updt::ExtensibleMCMC.MCMCParamUpdate, θ)\nExtensibleMCMC.coords(updt::ExtensibleMCMC.MCMCParamUpdate)\nExtensibleMCMC.subidx(θ, updt::ExtensibleMCMC.MCMCParamUpdate)\nExtensibleMCMC.compute_gradients_and_momenta!(\n    updt::ExtensibleMCMC.MCMCParamUpdate, ws::ExtensibleMCMC.LocalWorkspace, ::Any\n)","category":"page"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.log_prior-Tuple{ExtensibleMCMC.MCMCParamUpdate,Any}","page":"Updates & Decorators","title":"ExtensibleMCMC.log_prior","text":"log_prior(updt::MCMCParamUpdate, θ)\n\nEvaluate log-prior at θ.\n\n\n\n\n\n","category":"method"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.coords-Tuple{ExtensibleMCMC.MCMCParamUpdate}","page":"Updates & Decorators","title":"ExtensibleMCMC.coords","text":"coords(updt::MCMCParamUpdate)\n\nReturn a list of coordinates that updt is concerned with\n\n\n\n\n\n","category":"method"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.subidx-Tuple{Any,ExtensibleMCMC.MCMCParamUpdate}","page":"Updates & Decorators","title":"ExtensibleMCMC.subidx","text":"subidx(θ, updt::MCMCParamUpdate)\n\nReturn a view of subset of θ that updt is concerned with\n\n\n\n\n\n","category":"method"},{"location":"manual/updates_and_decorators/#ExtensibleMCMC.compute_gradients_and_momenta!-Tuple{ExtensibleMCMC.MCMCParamUpdate,ExtensibleMCMC.LocalWorkspace,Any}","page":"Updates & Decorators","title":"ExtensibleMCMC.compute_gradients_and_momenta!","text":"compute_gradients_and_momenta!(\n    updt::MCMCParamUpdate, ws::LocalWorkspace, ::Any\n)\n\nTo be overwritten for methods that are gradient or momentum based.\n\n\n\n\n\n","category":"method"},{"location":"manual/mcmc_schedule/#Scheduling-the-steps-to-take-with-MCMCSchedule-1","page":"MCMC Schedule","title":"Scheduling the steps to take with MCMCSchedule","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#tutorial_mean_of_bivariate_gsn-1","page":"Estimate mean of a bivariate Gaussian","title":"Estimating mean of a bivariate Gaussian","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"For this tutorial we will show to estimate a mean of a bivariate Gaussian random variable from its 10 observations using a package ExtensibleMCMC.jl. We will define a target law and two methods: set_parameters! and loglikelihood that dispatch on our target law. We will then generate some data, show how to parameterize the Markov chain and run the sampler. Finally, we will show how to inspect the results.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#Defining-the-target-law-1","page":"Estimate mean of a bivariate Gaussian","title":"Defining the target law","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"In this folder we have already defined some examples of the targets laws and a Gaussian law (with a possibility to estimate its mean and covariance matrix) is one of them. For the pedagogical purposes we define the new BivariateGaussian struct below.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"We start from defining the target law.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"using Distributions\nusing ExtensibleMCMC\nconst eMCMC = ExtensibleMCMC\n\nmutable struct BivariateGaussian{T}\n    P::T\n    function BivariateGaussian(μ, Σ)\n        @assert length(μ) == 2 && size(Σ) == (2,2)\n        P = MvNormal(μ, Σ)\n        new{typeof(P)}(P)\n    end\nend","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"We chose to define it as a mutable struct and use a pre-defined MvNormal struct from Distributions package to encode the probability law. In this way, when parameters change, we may define a new MvNormal struct, with new parameters and then write over the field P of BivariateGaussian, changing it to a new struct with new parameters. !!! tip     Depending on the application, you might want to consider changing this convention, define the target law using an immutable struct and have the representation of the probability law be represented by a mutable struct so that its parameters can be changed or, alternatively, have the parameters themselves be represented internally by a mutable vector.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"ExtensibleMCMC.jl expects to have two functions implemented for the target law. The first one is a setter of new parameters","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"function eMCMC.set_parameters!(gsn::BivariateGaussian, loc2glob_idx, θ)\n    μ, Σ = params(gsn.P)\n    μ[loc2glob_idx] .= θ\n    gsn.P = MvNormal(μ, Σ)\nend","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"Here, loc2glob_idx is a vector of indices pointing to parameters that are to be updated. For instance, if the MCMC step concerns only entries 3 and 6 of the 10 dimensional parameter vector θ, then loc2glob_idx=[3,6]. The second expected method is evaluation of the log-likelihood that extends the method defined in Distributions for the target law:","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"function Distributions.loglikelihood(gsn::BivariateGaussian, observs)\n    ll = 0.0\n    for obs in observs\n        ll += logpdf(gsn.P, obs)\n    end\n    ll\nend","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"Here, logpdf is defined in Distributions and works by the virtue of typeof(gsn.P) <: MvNormal.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"We're good to go!","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#Generating-the-data-1","page":"Estimate mean of a bivariate Gaussian","title":"Generating the data","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"We may simulate some test data. The important point is that unless you overload the update functions yourself, the data should be stored in the format of a NamedTuple with fields P containing the target law and obs with a vector of observations.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"using Random\nRandom.seed!(10)\nμ, Σ = [1.0, 2.0], [1.0 0.5; 0.5 1.0]\ntrgt = MvNormal(μ, Σ)\nnum_obs = 10\n\ndata = (\n    P = BivariateGaussian(rand(2), Σ),\n    obs = [rand(trgt) for _ in 1:num_obs],\n)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"In here we set the mean of P to random vales. The actual values don't matter and will be overwritten by the θinit—the initial guess for the mean.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#Parametrizing-the-MCMC-sampler-1","page":"Estimate mean of a bivariate Gaussian","title":"Parametrizing the MCMC sampler","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"We will start with a simple Metropolis-within-Gibbs algorithm that does single-site updates (alternately updating the two coordinates of the mean) and we will run it for $10^3## iterations. We will also use improper flat priors.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"note: Note\none update of coordinate 1 + one update of coordinate 2 == a single MCMC iteration","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"This can be simply encoded as follows:","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(UniformRandomWalk([1.0]), [1]; prior=ImproperPrior()),\n            RandomWalkUpdate(UniformRandomWalk([1.0]), [2]; prior=ImproperPrior()),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#Running-the-sampler-1","page":"Estimate mean of a bivariate Gaussian","title":"Running the sampler","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"With parameterization of the sampler in place, running it is a one-liner","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"workspace, local_workspaces = run!(mcmc_params...)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#Inspecting-the-results-1","page":"Estimate mean of a bivariate Gaussian","title":"Inspecting the results","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"The output of the sampler is a global Workspace and all local Workspaces. The global workspace holds the entire history of the chain. We can plot it, together with the observations and the true mean to see if we've done OK.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"using Plots\nfunction plot_results(ws)\n    θhist = collect(Iterators.flatten(ws.sub_ws.state_history))\n    p = plot(map(x->x[1], θhist), map(x->x[2], θhist))\n    scatter!(map(x->x[1], data.obs), map(x->x[2], data.obs), label=\"observations\")\n    scatter!(map(x->[x], μ)..., label=\"true mean\", marker=:star, ms=10)\n    display(p)\nend\nplot_results(workspace)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"(Image: simple_unif_rw)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"It turns out we did!","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#mean_of_bivariate_gsn_adpt-1","page":"Estimate mean of a bivariate Gaussian","title":"Mis-specification of hyper-parameters and adaptation","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"One of the reasons why we did relatively well in recovering the posterior over the mean parameter was because our proposals were quite decent. However, finding good proposals is a delicate issue. For the uniform random walker this translates to finding a good value for the half-range of steps ϵ. What happens if we set it to too small?","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(UniformRandomWalk([0.1]), [1]; prior=ImproperPrior()),\n            RandomWalkUpdate(UniformRandomWalk([0.1]), [2]; prior=ImproperPrior()),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)\n\nworkspace, local_wss = run!(mcmc_params...)\nplot_results(workspace)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"(Image: simple_unif_rw_too_small_epsilon)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"Well, we can see that we are much much slower in exploring the posterior. Finding ϵ by hand might be problematic and to this end there are standard adaptation techniques that target fixed acceptance rate of the sampler by adjusting the ϵ parameter. We can turn such adaptive schemes on using ExtensibleMCMC and then no matter that we start from a mis-specified ϵ, after some burn-in we should find much better candidates for it.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(\n                UniformRandomWalk([0.1]), [1];\n                prior=ImproperPrior(),\n                adpt=AdaptationUnifRW(\n                    [0.0];\n                    adapt_every_k_steps=50,\n                    scale=0.1,\n                ),\n            ),\n            RandomWalkUpdate(\n                UniformRandomWalk([0.1]), [2];\n                prior=ImproperPrior(),\n                adpt=AdaptationUnifRW(\n                    [0.0];\n                    adapt_every_k_steps=50,\n                    scale=0.1,\n                ),\n            ),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)\n\nworkspace, local_wss = run!(mcmc_params...)\nplot_results(workspace)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"(Image: simple_unif_rw_adpt)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#Gaussian-random-walk-proposals-with-single-site-updates-1","page":"Estimate mean of a bivariate Gaussian","title":"Gaussian random walk proposals with single-site updates","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"Sampling from the uniforms may be easily substituted with sampling from Gaussians as the following example demonstrates","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(\n                GaussianRandomWalk([1.0]), [1];\n                prior=ImproperPrior(),\n            ),\n            RandomWalkUpdate(\n                GaussianRandomWalk([1.0]), [2];\n                prior=ImproperPrior(),\n            ),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)\n\nworkspace, local_wss = run!(mcmc_params...)\nplot_results(workspace)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"(Image: simple_gsn_rw)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#Bivariate-random-walk-proposals-1","page":"Estimate mean of a bivariate Gaussian","title":"Bivariate random walk proposals","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"Naturally, it might be desirable to substitute single-site updates with joint updates. This is again very easily implementable:","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"using LinearAlgebra\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(\n                GaussianRandomWalk(0.5*Diagonal{Float64}(I, 2)), [1,2];\n                prior=ImproperPrior(),\n            ),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)\n\nworkspace, local_wss = run!(mcmc_params...)\nplot_results(workspace)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"(Image: biv_gsn_rw)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"Of course, the higher the dimension of proposals the more difficult it becomes to find a suitable covariance matrix for the proposals. For instance, this is what happens if the covariance is not scaled suitably:","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"using LinearAlgebra\nmcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(\n                GaussianRandomWalk(0.001*Diagonal{Float64}(I, 2)), [1,2];\n                prior=ImproperPrior(),\n            ),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)\n\nworkspace, local_wss = run!(mcmc_params...)\nplot_results(workspace)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"(Image: biv_gsn_rw_too_small)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#Haario-type-adaptation-for-multivariate-Gaussian-random-walk-proposals-1","page":"Estimate mean of a bivariate Gaussian","title":"Haario-type adaptation for multivariate Gaussian random walk proposals","text":"","category":"section"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"We may however employ Haario-type adaptive schemes very easily to learn the covariance in an adaptive way.","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"mcmc_params = (\n    mcmc = MCMC(\n        [\n            RandomWalkUpdate(\n                GaussianRandomWalkMix(\n                    0.01*Diagonal{Float64}(I, 2),\n                    0.01*Diagonal{Float64}(I, 2)\n                ),\n                [1,2];\n                prior=ImproperPrior(),\n                adpt=HaarioTypeAdaptation(\n                    rand(2);\n                    adapt_every_k_steps=50,\n                    f=((x,y,z)->(0.01+1/y^(1/3))),\n                ),\n            ),\n        ]\n    ),\n    num_mcmc_steps = Integer(1e3),\n    data = data,\n    θinit = [0.0, 0.0],\n)\n\nworkspace, local_wss = run!(mcmc_params...)\nplot_results(workspace)","category":"page"},{"location":"tutorials/mean_of_bivariate_gaussian/#","page":"Estimate mean of a bivariate Gaussian","title":"Estimate mean of a bivariate Gaussian","text":"(Image: biv_gsn_rw_adpt)","category":"page"},{"location":"get_started/priors/#Priors-1","page":"Priors","title":"Priors","text":"","category":"section"},{"location":"get_started/priors/#Improper-priors-1","page":"Priors","title":"Improper priors","text":"","category":"section"},{"location":"get_started/priors/#Standard-priors-relying-on-Distributions.jl-1","page":"Priors","title":"Standard priors relying on Distributions.jl","text":"","category":"section"},{"location":"manual/internal_structure/#manual_start-1","page":"Internal structure","title":"Understanding the internal components of the sampler","text":"","category":"section"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"It is important to understand the main principles behind the underlying algorithm, as they shed light on understanding the individual components. Once you understand the big picture it should also be easier to write your own extensions.","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"The structure of the algorithm can be summarized with the following graph which we will break down below:","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"(Image: internal structure)","category":"page"},{"location":"manual/internal_structure/#Inputs-1","page":"Internal structure","title":"Inputs","text":"","category":"section"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"The inputs to the algorithm are of three types.","category":"page"},{"location":"manual/internal_structure/#MCMC-1","page":"Internal structure","title":"MCMC","text":"","category":"section"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"The MCMC object is simply a list of updates and a specification of a backend. At each MCMC iteration the sampler will cycle through the list of these updates and perform each of them consecutively, as depicted in the red box in The Algorithm (subject to some modifications, TODO see advanced use). This list is de facto how you point to a specific MCMC algorithm and ask the sampler to use it. The last, optional argument backend is a way to use your own Workspaces. If default backend is used, then also default Workspaces will be created at the Initialization step.","category":"page"},{"location":"manual/internal_structure/#Callbacks-1","page":"Internal structure","title":"Callbacks","text":"","category":"section"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"Callbacks are instructions that allow for certain interactions with the state of the sampler while the sampler is still working. In The Algorithm section of a graph you can see that each callback may be executed before and after any call to an MCMC update. These can be such instructions as:","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"print useful info to the console about the state of the sampler\nupdate diagnostic plots\nsave the data to a csv file","category":"page"},{"location":"manual/internal_structure/#Other-1","page":"Internal structure","title":"Other","text":"","category":"section"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"These are some prerequisites for running an MCMC sampler, such as:","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"the data\nspecification of the number of MCMC iterations\ninitial guess of a parameter","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"As well as some additional named options (kwargs...) that will be passed down to various initializers and that may be used by your own Workspaces etc.","category":"page"},{"location":"manual/internal_structure/#Initialization-1","page":"Internal structure","title":"Initialization","text":"","category":"section"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"At the time of initialization of the sampler the global, and then, local workspaces are created. The concept of workspaces is central to ExtensibleMCMC and it is the reason why the package can be efficient even for very computationally intensive problems. The workspaces are essentially pre-allocated pieces of memory needed by the MCMC sampler. Consequently, if implemented correctly, the bottleneck of the algorithm should lie in computations and not memory-allocations.","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"tip: Tip\nOften times local workspaces are best conceptualized as a window view of some substate of the global workspace. The global workspace is initialized before local workspaces and is passed to the initializers of local workspaces. Consequently, it is often reasonable to define certain fields of the local workspaces as views to the relevant fields of the global workspace.","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"After workspaces, the MCMCSchedule is initialized. It is an iterator that iterates through the MCMC steps and at each step iterates through updates to perform. In the simplest setting it takes a form of a simple double for loop as illustrated in The Algorithm, but it can be modified.","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"Finally, each of the callback is given a chance to perform some initializations.","category":"page"},{"location":"manual/internal_structure/#The-algorithm-1","page":"Internal structure","title":"The algorithm","text":"","category":"section"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"In principle, there is nothing explicit about The Algorithm being a representation of an MCMC algorithm. It becomes one implicitly, by the virtue of updates being of the MCMC type.","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"The important part is marked in red. It represents a single MCMC update and illustrates that each update sees the corresponding pair of update and its local workspace as well global workspace and performs updates based on instructions in update and using pieces of memory that are in a local and the global workspace.","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"Additionally, notice that prior to each call to mcmc update there is an update call that allows for some exchange of information between the local and global workspaces.","category":"page"},{"location":"manual/internal_structure/#","page":"Internal structure","title":"Internal structure","text":"See further sections of this manual to learn more about various components of the algorithm's flow above.","category":"page"},{"location":"get_started/callbacks/#Callbacks-1","page":"Callbacks","title":"Callbacks","text":"","category":"section"},{"location":"get_started/callbacks/#ProgressPrintCallback-1","page":"Callbacks","title":"ProgressPrintCallback","text":"","category":"section"},{"location":"get_started/callbacks/#SavingCallback-1","page":"Callbacks","title":"SavingCallback","text":"","category":"section"},{"location":"#ExtensibleMCMC.jl-1","page":"Home","title":"ExtensibleMCMC.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A modular implementation of the Markov chain Monte Carlo (MCMC) algorithm focused on the ease of its extensibility.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The package comes with enough functionality to:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"run various MCMC algorithms\n[ ] Metropolis-Hastings updates (MH) with\n[ ] Random walk proposals\n[x] drawn from Uniform on additive and log scale (+ adaptation of steps targeting acceptance rate)\n[ ] drawn from Gaussian on additive and log scale (+ Haario-type adaptation)\n[ ] Langevin proposals (MALA)\n[ ] Hamiltionan dynamics\n[ ] Pseudo-marginal updates\n[ ] Non-reversible chains\n[ ] Zig-zag algorithm\nprint-out progress information to a console\nsave intermediate results to csv files\nprovide online diagnostic plots with ExtensibleMCMCPlots.jl extension","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Most importantly however, it is structured in a way to allow user-modifications to the internal flow of the algorithm and admit extensions to compute-intensive problems that don't neatly fit into frameworks of other Julia's MCMC packages.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Depending on your experience and intended use of this package you might consider starting at different places of this documentation.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"For a quick overview of this package's main functionality see Get started\nFor a systematic introduction to all functionality introduced in this package see the Manual\nFor a didactic introduction to problems that can be solved using our package see the Tutorials\nIf you have a problem that you think can be addressed with this package, then check out the How-to guides to see if the answer is already there.","category":"page"},{"location":"how_to_guides/first_how_to/#first_how_to-1","page":"(TODO) First how to","title":"First how-to","text":"","category":"section"}]
}
